common\ICopy.java
package common;
/**
 * 本接口表示当前对象可被快速复制，不需要提供序列化接口，但速度要远快于序列化。
 * @author 申远
 *
 * @param <T> 待复制对象的类型
 */
public interface ICopy<T extends ICopy<T>> {
	/**
	 * 复制某个对象，这是一个深度复制，源对象和复制后的对象将具有相同的初值，但是具有不同的内存地址
	 * @return 一个复制后的对象的引用
	 */
	public T copy();
}
common\ObjectCopy.java
package common;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
/**
 * 实现对象的深度复制
 * @author 申远
 *
 */
public class ObjectCopy {
	@SuppressWarnings({ "unchecked", "rawtypes" })
	/**
	 * 将指定的对象复制一份并返回，若果指定的对象实现了ICopy这个接口，本方法将直接调用ICopy中的相应方法。
	 * 若果没有实现ICopy接口，但实现了Serializable接口，方法将尝试使用序列化复制对象。
	 * 如果指定的对象没有实现这两个接口中的任意一个，本方法将返回一个null值
	 * @param source 待复制的对象
	 * @return 一个新的对象，与源对象具有相同的初值，但是具有不同的内存地址。
	 */
	public static <T> T newInstance(T source){
		T result=null;
		if(source instanceof ICopy){
			result=(T) ((ICopy) source).copy();
		}
		else if(source instanceof Serializable){
			try {
				System.out.println("shit");
				ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
				ObjectOutputStream objectOutputStream=new ObjectOutputStream(byteArrayOutputStream);
				objectOutputStream.writeObject(source);
				ByteArrayInputStream byteArrayInputStream=new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
				ObjectInputStream objectInputStream=new ObjectInputStream(byteArrayInputStream);
				result=(T) objectInputStream.readObject();
				objectInputStream.close();
				byteArrayInputStream.close();
				objectOutputStream.close();
				byteArrayOutputStream.close();
			} catch (IOException | ClassNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}			
		}
		return result;
	}
}
data\dao\HibernateDataContext.java
package data.dao;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import org.hibernate.Criteria;
import org.hibernate.HibernateException;
import org.hibernate.LockMode;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.hibernate.criterion.Example;
import org.hibernate.criterion.Projections;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class HibernateDataContext implements  IHibernateDataContext {
	
	 private static final Logger log = LoggerFactory.getLogger(HibernateDataContext.class);
	 private Session session;
	 private Transaction tran;
	 //private boolean IsInTransaction;
	 
//	public void setIsInTransaction(boolean isInTransaction) {
//		IsInTransaction = isInTransaction;
//	}
	public HibernateDataContext()
	 {
		 session=HibernateSessionFactory.getSession();
		 tran=null;
	 }
	 
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#save(java.lang.Object)
	 */
	public void save(Object item) {
		// TODO Auto-generated method stub
		log.debug("saving item");
		if(item==null)
		{
			log.debug("item is null");
			throw(new NullPointerException() );
		}
		boolean tranFlag=false;
		if(!IsInTransaction())
		{
			this.BeginTransaction();
			tranFlag=true;
		}
		
		session.save(item);
		if(!IsInTransaction()||tranFlag)
		{
			try 
			{
				this.Commit();
				//session.flush();
				log.debug("save successful");
			}
			catch(RuntimeException re)
			{
				this.Rollback();
		        log.error("save faile", re);
		        throw re;
			}
		}
		
	}
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#delete(java.lang.Object)
	 */
	public void delete(Object item ) {
		// TODO Auto-generated method stub
		log.debug("deleting item");
		if(item==null)
		{
			log.debug("item is null");
			throw(new NullPointerException() );
		}
		boolean tranFlag=false;
		if(!IsInTransaction())
		{
			this.BeginTransaction();
			tranFlag=true;
		}
		session.delete(item);
		if(!IsInTransaction()||tranFlag)
		{
			try 
			{
				this.Commit();
				//session.flush();
				log.debug("delete successful");
			}
			catch(RuntimeException re)
			{
				this.Rollback();
				log.error("delete failed", re);
		        throw re;
			}
		}
	}
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#update(java.lang.Object)
	 */
	public void update(Object item)
	{
		//先清空一下Session
		session.clear();
		// TODO Auto-generated method stub
		log.debug("updateing item");
		if(item==null)
		{
			log.debug("item is null");
			throw(new NullPointerException() );
		}
		boolean tranFlag=false;
		if(!IsInTransaction())
		{
			this.BeginTransaction();
			tranFlag=true;
		}
		
		session.update(item);
		if(!IsInTransaction()||tranFlag)
		{
			try 
			{
				this.Commit();
				//session.flush();
				log.debug("update successful");
			}
			catch(RuntimeException re)
			{
				this.Rollback();
				log.error("update failed", re);
		        throw re;
			}
		}
	}
	
	
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#findById(java.lang.Class, java.lang.String)
	 */
	@SuppressWarnings("unchecked")
	public<T> T findById(Class<T> clazz,Serializable id)
	{
		log.debug("getting Object instance with id: " + id);
		try
		{
			//T t=clazz.newInstance();
			return (T)session.get(clazz,id);
			//return t;
		}
		catch (RuntimeException re)
		{
			log.error("findById failed", re);
			throw re;
		}
		
		
	}
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#findByExample(java.lang.Object)
	 */
	public<T> List<T> findByExample(Object instance) {
		log.debug("finding instance instance by example");
		try {
          @SuppressWarnings("unchecked")
		List<T> results = (List<T>)getSession().createCriteria(instance.getClass())
          				.add(Example.create(instance)).list();
                  //.createCriteria("Student")
                  //.add(Example.create(instance))
          log.debug("find by example successful, result size: " + results.size());
          return results;
      } catch (RuntimeException re) {
          log.error("find by example failed", re);
          throw re;
      }
		
	}
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#findByProperty(java.lang.Class, java.lang.String, java.lang.Object)
	 */
	public<T> List<T> findByProperty(Class<T> clazz,String propertyName, Object value) {
		log.debug("finding Student instance with property: " + propertyName
	            + ", value: " + value);
	      try {
	    	  String queryString = "from "+clazz.getName()+" as model where model." 
	         						+ propertyName + "= ?";
	    	  System.out.println(queryString);
	         Query queryObject = getSession().createQuery(queryString);
			 queryObject.setParameter(0, value);
			 return (List<T>)queryObject.list();
	      } catch (RuntimeException re) {
	         log.error("find by property name failed", re);
	         throw re;
	      }
	}
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#findAll(java.lang.Class)
	 */
	
	public<T> List<T> findAll(Class<T> clazz) {
		log.debug("finding all object instances");
		try {
			String queryString = "from "+clazz.getName();
	         Query queryObject = getSession().createQuery(queryString);
			 return (List<T>)queryObject.list();
		} catch (RuntimeException re) {
			log.error("find all failed", re);
			throw re;
		}
	}
	
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#findAll(java.lang.Class, int, int)
	 */
	public<T> List<T> findAll(Class<T> clazz,int pageIndex, int pageSize )
	{
		log.debug("finding all object instances");
		try {
			String queryString = "from "+clazz.getName();
	         Query queryObject = getSession().createQuery(queryString);
	         queryObject.setFirstResult(pageIndex);
	         queryObject.setMaxResults(pageSize);
			 return (List<T>)queryObject.list();
		} catch (RuntimeException re) {
			log.error("find all failed", re);
			throw re;
		}
	}
	/*
	 * 根据HQL语句查询对象
	 */
	public<T> List<T> queryByHql(String hql)
	{
		log.debug("query object by hql");
		try{			
			Query queryObject=getSession().createQuery(hql);
			return (List<T>)queryObject.list();				
		}catch (RuntimeException re) {
			log.error("query failed", re);
			throw re;
		}
			
	}
	
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#merge(java.lang.Class, java.lang.Object)
	 */
	
	public<T> T merge(Class<T> clazz,Object detachedInstance) {
      log.debug("merging object instance");
    	  if(detachedInstance==null)
	  		{
	  			log.debug("item is null");
	  			throw(new NullPointerException() );
	  		}
	  		boolean tranFlag=false;
	  		if(!IsInTransaction())
	  		{
	  			this.BeginTransaction();
	  			tranFlag=true;
	  		}
          @SuppressWarnings("unchecked")
		T result = (T)session.merge(detachedInstance);          
         if(!IsInTransaction()||tranFlag)
         {
        	 try           			
        	 {          				
        		 this.Commit();         				
        		 //session.flush();         				
        		 log.debug("merge successful");         			
        	 }       			
        	 catch(RuntimeException re)          			
        	 {          				
        		 this.Rollback();          				
        		 log.error("merge failed", re);         		       
        		 throw re;		
        	 }
         }
		return result;
	}
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#getCount(java.lang.Class)
	 */
	public<T> int getCount(Class<T> clazz)
	{
		Criteria  criteria=session.createCriteria(clazz);
		criteria.setProjection(Projections.rowCount()).uniqueResult();
		criteria.setProjection(null);    
		criteria.list();
		 return (Integer)criteria.list().size();
	}
	
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#attachDirty(java.lang.Object)
	 */
	
	public void attachDirty(Object item) {
		
		log.debug("attaching dirty object instance");
		if(item==null)
		{
			log.debug("item is null");
			throw(new NullPointerException() );
		}
		boolean tranFlag=false;
		if(!IsInTransaction())
		{
			this.BeginTransaction();
			tranFlag=true;
		}
		session.saveOrUpdate(item);
		if(!IsInTransaction()||tranFlag)
		{
			try 
			{
				this.Commit();
				//session.flush();
				log.debug("attach successful");
			}
			catch(RuntimeException re)
			{
				this.Rollback();
				log.error("attach failed", re);
		        throw re;
			}
		}
	}
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#attachClean(java.lang.Object)
	 */
	
	public void attachClean(Object item) {
		log.debug("attaching clean object instance");
		if(item==null)
		{
			log.debug("item is null");
			throw(new NullPointerException() );
		}
		boolean tranFlag=false;
		if(!IsInTransaction())
		{
			this.BeginTransaction();
			tranFlag=true;
		}
		session.lock(item, LockMode.NONE);
		if(!IsInTransaction()||tranFlag)
		{
			try 
			{
				this.Commit();
				//session.flush();
				log.debug("attach successful");
			}
			catch(RuntimeException re)
			{
				this.Rollback();
				log.error("attach failed", re);
		        throw re;
			}
		}
	}
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#getSession()
	 */
	
	public Session getSession() {
		if(this.session!=null)
		{
			return this.session;
		}
		else
		{
			return HibernateSessionFactory.getSession();
		}
	}
	/* (non-Javadoc)
	 * @see dao.IHibernateDataContext#IsInTransaction()
	 */
	 public boolean IsInTransaction() {
			return tran != null && tran.isActive();
		}
	 /* (non-Javadoc)
	 * @see dao.IHibernateDataContext#BeginTransaction()
	 */
	 public void BeginTransaction() 
	 {
		 log.debug("Begin a transaction");
		 if(IsInTransaction())
		 {
			 log.debug("A transaction is already opened");
			 throw(new IllegalStateException ("A transaction is already opened") );
		 }
		 else
		 {
			 try
             {
                 tran = session.beginTransaction();
                 log.debug("Openning a transaction  successful");
             }
             catch(HibernateException ex)
             {
            	 log.error("Open a transaction  Error");
                 throw (ex);
             }
		 }
	 }
	 
	 /* (non-Javadoc)
	 * @see dao.IHibernateDataContext#Commit()
	 */
	 public void Commit() 
	 {
		 if(!IsInTransaction())
		 {
			 log.debug("Operation requires an active transaction");
			 throw(new IllegalStateException ("Operation requires an active transaction") );
		 }
		 else
		 {
			 try
             {
                 tran.commit();                
                 log.debug("Commit successful");
             }
             catch(HibernateException ex)
             {
            	 log.error("Commit a transaction  Error");
                 throw (ex);
             }
		 }
	 }
	 
	 /* (non-Javadoc)
	 * @see dao.IHibernateDataContext#Rollback()
	 */
	 public void Rollback()
	 {
		 if(!IsInTransaction())
		 {
			 log.debug("Operation requires an active transaction");
			 throw(new IllegalStateException ("Operation requires an active transaction") );
		 }
		 else
		 {
			 try
             {
                 tran.commit();                
                 log.debug("Commit successful");
             }
             catch(HibernateException ex)
             {
            	 log.error("Commit a transaction  Error");
                 throw (ex);
             }
		 }
	 }
	 
	 /* (non-Javadoc)
	 * @see dao.IHibernateDataContext#IsDirty()
	 */
	 public boolean IsDirty()
	 {
		 return session.isDirty();
	 }
	 
	//value[i]为第i个查询条件propertyName[i]的值          （本方法已通过测试）  
	 
		/*多条件查询,查询条件的值为空时自动除去该条件  
		* rigor为true时采用精确查询  
		*/ 
		public List searchByPropertys(String model,String[]propertyName,Object[] value,boolean rigor){    
		    StringBuffer sqlBuffer = new StringBuffer();  
		    String ralation=" like ";  
		    if(rigor){  
		     ralation=" = ";  
		    }  
		    sqlBuffer.append("from "+model+" as model\n");  
		    int len=propertyName.length;  
		    List list=new ArrayList();  
		    boolean first=true;  
		    for(int i=0;i< len;i++){  
		     if(value[i]!=null){  
		     if(first){      
		      sqlBuffer.append(" where "+ "model."+ propertyName[i] + ralation+" ?\n");      
		      list.add(value[i]);  
		      first=false;  
		     }else{      
		      sqlBuffer.append(" and "+ "model."+ propertyName[i] +ralation+ " ?\n");      
		      list.add(value[i]);  
		     }  
		    }  
		    }  
		    
		     try { 
		    	 Query queryObject = session.createQuery(sqlBuffer.toString());  
		             for(int i=0;i< list.size();i++){  
		             if(rigor){  
		              queryObject.setParameter(i, list.get(i));  
		             }else{  
		              queryObject.setParameter(i, "%"+list.get(i)+"%");  
		             }  
		             
		      }  
		            
		            list=queryObject.list();  
		            //closeSession(session);  
		      return list;  
		         } catch (RuntimeException re) {  
		            log.error("find by property name failed", re);  
		            throw re;  
		         }  
		 
		}
		
		/*多条件查询,可以使用Between条件,查询条件的值为空时自动除去该条件  
		* rigor为true时采用精确查询  
		*/ 
		public List searchByPropertysBetween(String model,String[]propertyName,Object[] value,boolean rigor,String BetweenProperty,Object[] valueObject){    
		    System.out.println("序列化"+value[0].toString());
			StringBuffer sqlBuffer = new StringBuffer();  
		    String ralation=" like ";  
		    if(rigor){  
		     ralation=" = ";  
		    }  
		    sqlBuffer.append("from "+model+" as model\n");  
		    int len=propertyName.length;  
		    List list=new ArrayList();  
		    boolean first=true;  
		   for(int i=0;i< len;i++){  
		     if(value[i]!=null){  
		     if(first){      
		      sqlBuffer.append(" where "+ "model."+ propertyName[i] + ralation+" ?\n");      
		      list.add(value[i]);  
		      first=false;  
		     }else{      
		      sqlBuffer.append(" and "+ "model."+ propertyName[i] +ralation+ " ?\n");      
		      list.add(value[i]);  
		     }  
		    }  
		    }  
		   System.out.println(valueObject[0].toString());
		   System.out.println(valueObject[1].toString());
		    sqlBuffer.append(" and model."+BetweenProperty +" between ? and ? \n");
		    list.add(valueObject[0]);
		    list.add(valueObject[1]);
		     try { 
		    	 Query queryObject = session.createQuery(sqlBuffer.toString());  
		             for(int i=0;i< list.size();i++){  
		             if(rigor){  
		              queryObject.setParameter(i, list.get(i));  
		             }else{  
		              queryObject.setParameter(i, "%"+list.get(i)+"%");  
		             }  
		             
		      }  
		       System.out.println(sqlBuffer.toString());     
		            list=queryObject.list();  
		            //closeSession(session);  
		      return list;  
		         } catch (RuntimeException re) {  
		            log.error("find by property name failed", re);  
		            throw re;  
		         }  
		 
		}
}
data\dao\HibernateSessionFactory.java
package data.dao;
import org.hibernate.HibernateException;
import org.hibernate.Session;
import org.hibernate.cfg.Configuration;
/**
 * Configures and provides access to Hibernate sessions, tied to the
 * current thread of execution.  Follows the Thread Local Session
 * pattern, see {@link http://hibernate.org/42.html }.
 */
public class HibernateSessionFactory {
    /** 
     * Location of hibernate.cfg.xml file.
     * Location should be on the classpath as Hibernate uses  
     * #resourceAsStream style lookup for its configuration file. 
     * The default classpath location of the hibernate config file is 
     * in the default package. Use #setConfigFile() to update 
     * the location of the configuration file for the current session.   
     */
    private static String CONFIG_FILE_LOCATION = "/data/configure/hibernate.cfg.xml";
	private static final ThreadLocal<Session> threadLocal = new ThreadLocal<Session>();
    private  static Configuration configuration = new Configuration();    
    private static org.hibernate.SessionFactory sessionFactory;
    private static String configFile = CONFIG_FILE_LOCATION;
	static {
    	try {
			configuration.configure(configFile);
			sessionFactory = configuration.buildSessionFactory();
		} catch (Exception e) {
			System.err
					.println("%%%% Error Creating SessionFactory %%%%");
			e.printStackTrace();
		}
    }
    private HibernateSessionFactory() {
    }
	
	/**
     * Returns the ThreadLocal Session instance.  Lazy initialize
     * the <code>SessionFactory</code> if needed.
     *
     *  @return Session
     *  @throws HibernateException
     */
    public static Session getSession() throws HibernateException {
        Session session = (Session) threadLocal.get();
		if (session == null || !session.isOpen()) {
			if (sessionFactory == null) {
				rebuildSessionFactory();
			}
			session = (sessionFactory != null) ? sessionFactory.openSession()
					: null;
			threadLocal.set(session);
		}
        return session;
    }
	/**
     *  Rebuild hibernate session factory
     *
     */
	public static void rebuildSessionFactory() {
		try {
			configuration.configure(configFile);
			sessionFactory = configuration.buildSessionFactory();
		} catch (Exception e) {
			System.err
					.println("%%%% Error Creating SessionFactory %%%%");
			e.printStackTrace();
		}
	}
	/**
     *  Close the single hibernate session instance.
     *
     *  @throws HibernateException
     */
    public static void closeSession() throws HibernateException {
        Session session = (Session) threadLocal.get();
        threadLocal.set(null);
        if (session != null) {
            session.close();
        }
    }
	/**
     *  return session factory
     *
     */
	public static org.hibernate.SessionFactory getSessionFactory() {
		return sessionFactory;
	}
	/**
     *  return session factory
     *
     *	session factory will be rebuilded in the next call
     */
	public static void setConfigFile(String configFile) {
		HibernateSessionFactory.configFile = configFile;
		sessionFactory = null;
	}
	/**
     *  return hibernate configuration
     *
     */
	public static Configuration getConfiguration() {
		return configuration;
	}
}
data\dao\IHibernateDataContext.java
package data.dao;
import java.io.Serializable;
import java.util.List;
import org.hibernate.Session;
public interface IHibernateDataContext {
	/**
	 * ADD方法
	 */
	public abstract void save(Object item);
	/**
	 * DELETE
	 */
	public abstract void delete(Object item);
	/**
	 * UPDATE
	 */
	public abstract void update(Object item);
	/**
	 * 根据ID获取对象
	 */
	public abstract <T> T findById(Class<T> clazz, Serializable id);
	/**
	 * 根据对象进行查询
	 */
	public abstract <T> List<T> findByExample(Object instance);
	public abstract <T> List<T> findByProperty(Class<T> clazz,
			String propertyName, Object value);
	
	/**
	 * 根据HQL语句查询对象
	 */
	public abstract <T> List<T> queryByHql(String hql);
	/**
	 * 获取全部
	 */
	public abstract <T> List<T> findAll(Class<T> clazz);
	/**
	 * 
	 * @param <T>
	 * @param clazz
	 * @param pageIndex 页码
	 * @param pageSize	返回的条数
	 * @return
	 */
	public abstract <T> List<T> findAll(Class<T> clazz, int pageIndex,
			int pageSize);
	/**
	 * MERGE
	 */
	public abstract <T> T merge(Class<T> clazz, Object detachedInstance);
	/**
	 * 计数
	 */
	public abstract <T> int getCount(Class<T> clazz);
	public abstract void attachDirty(Object item);
	public abstract void attachClean(Object item);
	public abstract Session getSession();
	/**
	 * 是否在事务中
	 * @return true or false
	 */
	public abstract boolean IsInTransaction();
	/**
	 * 开启一个事务
	 */
	public abstract void BeginTransaction();
	/**
	 * 提交事务
	 */
	public abstract void Commit();
	/**
	 * 事务回滚
	 */
	public abstract void Rollback();
	/**
	 * 脏数据
	 * @return true or false
	 */
	public abstract boolean IsDirty();
	
	/**
	 * 多条件查询
	 * */
	public List searchByPropertys(String model,String[]propertyName,Object[] value,boolean rigor);
	
	/*多条件查询,可以使用Between条件,查询条件的值为空时自动除去该条件  
	* rigor为true时采用精确查询  
	*/ 
	public List searchByPropertysBetween(String model,String[]propertyName,Object[] value,boolean rigor,String BetweenProperty,Object[] valueObject);
}
domain\core\algmodel\configuration\GepAlgorithm.java
package domain.core.algmodel.configuration;
import java.io.Serializable;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;
import domain.core.algmodel.genecomponent.Function;
import domain.core.algmodel.genecomponent.Variable;
/**
 * 本类是算法子系统实体类的入口，本类中保存有两部分内容，第一部分是有关算法实体类的参数，第二部分是一个对种群队列的引用
 * @author 申远
 * 
 */
public class GepAlgorithm implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = 9145263051145401068L;
	private int populationSize;
	private int normalGeneNumber;
	private int normalHeaderLength;
	private int normalTailLength;
	private int normalGeneLength;
	private int homeoticGeneNumber;
	private int homeoticHeaderLength;
	private int homeoticTailLength;
	private int homeoticGeneLength;
	private int individualLength;
	private Deque<Population> populationQueue=new ArrayDeque<Population>(2);
	private long maxGeneration;
	private float maxFitness;
	private List<Variable> variableList;
	private List<Function> functionList;
	
	/**
	 * 空构造函数
	 */
	public GepAlgorithm(){
		
	}
	/**
	 * 返回种群大小，即种群中包含的个体的数量。
	 * @return 种群大小
	 */
	public int getPopulationSize() {
		return populationSize;
	}
	/**
	 * 设置种群大小为用户指定的种群大小。
	 * @param populationNumber 指定的种群大小
	 */
	public void setPopulationSize(int populationNumber) {
		this.populationSize = populationNumber;
	}
	/**
	 * 返回个体中普通基因的数量，所有种群中的所有个体里面普通基因数量均相同。
	 * @return 个体中普通基因的数量
	 */
	public int getNormalGeneNumber() {
		return normalGeneNumber;
	}
	/**
	 * 设置个体中普通基因的数量
	 * @param geneNumber 设置个体中普通基因的数量
	 */
	public void setNormalGeneNumber(int geneNumber) {
		this.normalGeneNumber = geneNumber;
	}
	/**
	 * 返回个体中普通基因的头部长度，所有种群中所有个体的普通基因长度均相同。
	 * @return 普通基因头部的长度
	 */
	public int getNormalHeaderLength() {
		return normalHeaderLength;
	}
	/**
	 * 设置个体中普通基因的头部长度
	 * @param headerLength 普通基因的头部长度
	 */
	public void setNormalHeaderLength(int headerLength) {
		this.normalHeaderLength = headerLength;
	}
	/**
	 * 返回个体中同源基因的数量，所有种群中的所有个体里同源基因数量均相同。
	 * @return 同源基因的数量
	 */
	public int getHomeoticGeneNumber() {
		return homeoticGeneNumber;
	}
	/**
	 * 设置个体中同源基因的数量，所有种群中所有个体的同源基因的数量均相同。
	 * @param homeoticGeneNumber 同源基因的数量
	 */
	public void setHomeoticGeneNumber(int homeoticGeneNumber) {
		this.homeoticGeneNumber = homeoticGeneNumber;
	}
	/**
	 * 返回同源基因的头部长度
	 * @return 同源基因的头部长度
	 */
	public int getHomeoticHeaderLength() {
		return homeoticHeaderLength;
	}
	/**
	 * 设置同源基因的头部长度，所有种群中所有个体的同源基因长度均相同。
	 * @param homeoticHeaderLength 同源基因长度
	 */
	public void setHomeoticHeaderLength(int homeoticHeaderLength) {
		this.homeoticHeaderLength = homeoticHeaderLength;
	}
	/**
	 * 返回个体的总长
	 * @return 个体总长
	 */
	public int getIndividualLength() {
		return individualLength;
	}
	/**
	 * 设置个体长度，所有种群中所有个体的长度相同，个体的长度等于普通基因总长度+同源基因总长度，请严格按照此公式设置，系统不会验证此输入是否正确，但是
	 * 如果不符合此公式的话系统运行的时候会出现异常。
	 * @param individualLength 个体的长度
	 */
	public void setIndividualLength(int individualLength){
		this.individualLength=individualLength;
	}
	/**
	 * 将新的种群添加到种群队列的队尾，种群队列中只会保留两个种群，如果因为添加新种群导致种群队列的长度大于2，那么
	 * 种群队列队首的种群将自动出队。
	 * @param myPopulation 待添加的种群
	 */
	public void addPopulation(Population myPopulation){
		populationQueue.addLast(myPopulation);
		if(populationQueue.size()>2)
			populationQueue.removeFirst();
	}
	/**
	 * 返回种群队列，此队列中只包含两个种群。
	 * @return 种群队列
	 */
	public Deque<Population> getPopulationQueue(){
		return populationQueue;
	}
	/**
	 * 返回普通基因的尾部长度
	 * @return 普通基因的尾部长度
	 */
	public int getNormalTailLength() {
		return normalTailLength;
	}
	/**
	 * 设置普通基因的尾部长度，普通基因的尾长＝普通基因头长+max｛A|参与运算的函数的目数｝，请严格按照此公式设置，系统不会验证此输入是否正确，但是
	 * 如果不符合此公式的话系统运行的时候会出现异常,在设置此参数的时候，系统会自动生成普通基因的长度。
	 * @param normalTailLength 普通基因的尾部长度
	 */
	public void setNormalTailLength(int normalTailLength) {
		this.normalTailLength = normalTailLength;
		normalGeneLength=normalHeaderLength+this.normalTailLength;
	}
	/**
	 * 返回同源基因的尾部长度
	 * @return 同源基因的尾部长度
	 */
	public int getHomeoticTailLength() {
		return homeoticTailLength;
	}
	/**
	 * 设置同源基因的尾部长度，同源基因的尾长＝同源基因头长+max｛A|参与运算的函数的目数｝，请严格按照此公式设置，系统不会验证此输入是否正确，但是
	 * 如果不符合此公式的话系统运行的时候会出现异常,在设置此参数的时候，系统会自动生成同源基因的长度。
	 * @param homeoticTailLength 同源基因的尾部长度
	 */
	public void setHomeoticTailLength(int homeoticTailLength) {
		this.homeoticTailLength = homeoticTailLength;
		homeoticGeneLength=homeoticHeaderLength+this.homeoticTailLength;
	}
	/**
	 * 返回普通基因的长度，普通基因的长度＝普通基因的头长+普通基因的尾长，所有种群中所有个体的普通基因长度均相同。
	 * @return 普通基因的长度
	 */
	public int getNormalGeneLength() {
		return normalGeneLength;
	}
	/**
	 * 返回同源基因的长度，同源基因的长度＝同源基因的头长+同源基因的尾长，所有种群中所有个体的同源基因长度均相同。
	 * @return　同源基因的长度
	 */
	public int getHomeoticGeneLength() {
		return homeoticGeneLength;
	}
	/**
	 * 返回用户设置的最大演化代数，达到此演化代数后，系统将自动停机。
	 * @return　最大演化代数
	 */
	public long getMaxGeneration() {
		return maxGeneration;
	}
	/**
	 * 设置最大演化代数，达到此演化代数后系统将自动停机。
	 * @param maxGeneration　最大演化代数
	 */
	public void setMaxGeneration(long maxGeneration) {
		this.maxGeneration = maxGeneration;
	}
	/**
	 * 返回最大适应值，当系统发现某个个体达到最大适应值后也将停机。
	 * @return 最大适应值
	 */
	public float getMaxFitness() {
		return maxFitness;
	}
	/**
	 * 设置最大适应值，最大适应值为选择范围×输入矩阵的行数，请按照此公式进行设置，系统将不会验证设置是否正确，但是如果错误的话，系统在运行的时候会抛出异常。
	 * @param maxFitness
	 */
	public void setMaxFitness(float maxFitness) {
		this.maxFitness = maxFitness;
	}
	/**
	 * 返回终点集，终点集即为变量的集合。
	 * @return 终点集
	 */
	public List<Variable> getVariableList() {
		return variableList;
	}
	/**
	 * 设置终点集，即参与运算的所有的变量，变量的数目应为输入矩阵的列数+1，如不满足次条件，系统将在运行期间抛出异常。
	 * @param variableList
	 */
	public void setVariableList(List<Variable> variableList) {
		this.variableList = variableList;
	}
	/**
	 * 返回函数集
	 * @return 函数集
	 */
	public List<Function> getFunctionList() {
		return functionList;
	}
	/**
	 * 通过此方法可以设置参与运算的所有的函数。
	 * @param functionList 参与运算的函数
	 */
	public void setFunctionList(List<Function> functionList) {
		this.functionList = functionList;
	}
}
domain\core\algmodel\configuration\Individual.java
package domain.core.algmodel.configuration;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import common.ICopy;
import domain.core.algmodel.genecomponent.GenePiece;
import domain.core.algmodel.individualcomponent.HomeoticGene;
import domain.core.algmodel.individualcomponent.NormalGene;
/**
 * 个体类,种群中保存着个体的List
 * @author 个体类
 *
 */
public class Individual implements Comparable<Individual>,Serializable,ICopy<Individual>{
	private static final long serialVersionUID = -7942680950588488680L;
	private int normalGeneNumber;
	private int normalGeneHeaderLength;
	private int normalGeneLength;
	private int homeoticGeneNumber;
	private int homeoticGeneHeaderLength;
	private int homeoticGeneLength;
	
	
	private List<GenePiece> containedGenePieces;
	private List<GenePiece> normalGenePieces;
	private List<GenePiece> homeoticGenePieces;
	
	private List<NormalGene> normalGeneList;
	private List<HomeoticGene> homeoticGeneList;
	private Float fitness;
	private int selectedHomeoticGeneNumber;
	public Individual(){
	}
	/**
	 * 覆盖了Object的toString方法，本方法将以字符串的形式输出个体中所包含的全部Genepiece信息。
	 */
	@Override
	public String toString() {
		// TODO Auto-generated method stub
		StringBuffer result=new StringBuffer();
		result.append("正常基因:");
		for(NormalGene normalGene:getNormalGeneList()){
			for(GenePiece piece:normalGene.getHeader().getContainedGenePieces())
				result.append(piece.getSymbol()+" ");
			for(GenePiece piece:normalGene.getTail().getContainedGenePieces())
				result.append(piece.getSymbol()+" ");
		}
		result.append("\n同源基因:");
		for(HomeoticGene homeoticGene:getHomeoticGeneList()){
			for(GenePiece piece:homeoticGene.getHeader().getContainedGenePieces())
				result.append(piece.getSymbol()+" ");
			for(GenePiece piece:homeoticGene.getTail().getContainedGenePieces())
				result.append(piece.getSymbol()+" ");
		}
		return result.toString();
	}
	/**
	 * 比较当前个体的适应值和用户指定的某个个体的适应值，并将此结果返回
	 * @param　用户提供的待比较的个体
	 * @return 如果当前个体适应值小于参数适应值，返回负数，如果当前个体适应值等于参数个体适应值，返回0，如果当前个体适应值大于参数个体适应值，返回正数
	 */
	@Override
	public int compareTo(Individual o) {
		// TODO Auto-generated method stub
		return Float.compare(fitness, o.getFitness());
	}
	/**
	 * 一个个体可能具有多个同源基因，一个个体内的多个同源基因可能产生多个不同的表达式，这个方法将返回在对某个确定的输入集求解的时候使用哪个同源基因翻译个体
	 * @return 被选择的同源基因的编号，从0开始，最大值为普通基因数量－1
	 */
	public int getSelectedHomeoticGeneNumber() {
		return selectedHomeoticGeneNumber;
	}
	/**
	 * 设置在求解输入集的时候将使用哪个同源基因上传个体。
	 * @param selectedHomeoticGeneNumber 同源基因编号
	 */
	public void setSelectedHomeoticGeneNumber(int selectedHomeoticGeneNumber) {
		this.selectedHomeoticGeneNumber = selectedHomeoticGeneNumber;
	}
	/**
	 * 返回当前个体的适应值
	 * @return 当前个体的适应值
	 */
	public Float getFitness(){
		return fitness;
	}
	/**
	 * 设置当前个体的适应值
	 * @param fitness 当前个体的适应值
	 */
	public void setFitness(Float fitness) {
		this.fitness = fitness;
	}
	/**
	 * 返回个体中所包含的普通基因的List
	 * @return 个体中的所有普通基因
	 */
	public List<NormalGene> getNormalGeneList() {
		return normalGeneList;
	}
	/**
	 * 返回个体中所包含的同源基因的List
	 * @return 个体中的所有同源基因
	 */
	public List<HomeoticGene> getHomeoticGeneList() {
		return homeoticGeneList;
	}
	/**
	 * 返回个体中包含的所有基因片段，即按照线性顺序遍历所有的普通基因和所有的同源基因，请不要对这个List的大小进行修改，否则可能会出现错误。
	 * 此为对这个List修改将直接影响对应的基因，反之也是一样。
	 * @return 包含个体中所有基因片段的list
	 */
	public List<GenePiece> getContainedGenePieces(){
		return containedGenePieces;
	}
	/**
	 * 返回普通基因中包含的所有基因片段，即按照线性顺序遍历所有的普通基因，请不要对这个List的大小进行修改，否则会抛出异常。
	 * 此为对这个List修改将直接影响对应的基因，反之也是一样。
	 * @return 包含普通基因中所有基因片段的list
	 */
	public List<GenePiece> getNormalGenePieces(){
		return normalGenePieces;
	}
	/**
	 * 返回同源基因中包含的所有基因片段，即按照线性顺序遍历所有的同源基因，请不要对这个List的大小进行修改，否则会抛出异常。
	 * 此为对这个List修改将直接影响对应的基因，反之也是一样。
	 * @return 包含同源基因中所有基因片段的list
	 */
	public List<GenePiece> getHomeoticGenePieces(){
		return homeoticGenePieces;
	}
	/**
	 * 此方法只需要在初始的时候调用，勿在其他的情况下调用，这个方法将自动产生个体所包含的普通基因和同源基因，并自动设置好基因的头部，尾部等信息。
	 * 对这些基因的修改将直接影响个体中的基因片段的List，反之依然。
	 * @param genePieces 个体中所有同源基因和所有非同源的基因片段
	 * @param normalGeneNumber 普通基因的数量
	 * @param normalGeneHeaderLength 普通基因的头部长度
	 * @param normalGeneLength 一个普通基因的长度，普通基因的长度等于普通基因的头长+普通基因的尾长
	 * @param homeoticGeneNumber 同源基因的数量
	 * @param homeoticGeneHeaderLength 同源基因的头部长度
	 * @param homeoticGeneLength 一个同源基因的长度，同源基因的长度等于同源基因的头长+同源基因的尾长
	 */
	public void setContainedGenePieces(List<GenePiece> genePieces,int normalGeneNumber,int normalGeneHeaderLength,int normalGeneLength,int homeoticGeneNumber,int homeoticGeneHeaderLength,int homeoticGeneLength){
		this.containedGenePieces=genePieces;
		this.normalGeneHeaderLength=normalGeneHeaderLength;
		this.normalGeneLength=normalGeneLength;
		this.normalGeneNumber=normalGeneNumber;
		this.homeoticGeneHeaderLength=homeoticGeneHeaderLength;
		this.homeoticGeneLength=homeoticGeneLength;
		this.homeoticGeneNumber=homeoticGeneNumber;
		NormalGene normalGene;
		HomeoticGene homeoticGene;
		normalGeneList=new ArrayList<NormalGene>(normalGeneNumber);
		homeoticGeneList=new ArrayList<HomeoticGene>(homeoticGeneNumber);
		for(int i=0;i<normalGeneNumber;i++){
			normalGene=new NormalGene(normalGeneHeaderLength,normalGeneLength-normalGeneHeaderLength,
					containedGenePieces,i*normalGeneLength, (i+1)*normalGeneLength);
			normalGeneList.add(normalGene);
		}
		int normalGeneTotalLength=normalGeneLength*normalGeneNumber;
		for(int i=0;i<homeoticGeneNumber;i++){
			homeoticGene=new HomeoticGene(homeoticGeneHeaderLength,homeoticGeneLength-homeoticGeneHeaderLength,
					containedGenePieces,normalGeneTotalLength+i*homeoticGeneLength, normalGeneTotalLength+(i+1)*homeoticGeneLength);
			homeoticGeneList.add(homeoticGene);
		}
		int homeoticGeneTotalLenth=homeoticGeneLength*homeoticGeneNumber;
		normalGenePieces=genePieces.subList(0, normalGeneTotalLength);
		homeoticGenePieces=genePieces.subList(normalGeneTotalLength, normalGeneTotalLength+homeoticGeneTotalLenth);
	}
	@SuppressWarnings("unchecked")
	private void readObject(ObjectInputStream in){
		try {
			normalGeneHeaderLength=in.readInt();
			normalGeneLength=in.readInt();
			normalGeneNumber=in.readInt();
			homeoticGeneHeaderLength=in.readInt();
			homeoticGeneLength=in.readInt();
			homeoticGeneNumber=in.readInt();
			containedGenePieces=(List<GenePiece>) in.readObject();
			normalGeneList=(List<NormalGene>) in.readObject();
			homeoticGeneList=(List<HomeoticGene>) in.readObject();
			fitness=in.readFloat();
			selectedHomeoticGeneNumber=in.readInt();
			int normalGeneTotalLength=normalGeneLength*normalGeneNumber;
			int homeoticGeneTotalLenth=homeoticGeneLength*homeoticGeneNumber;
			normalGenePieces=containedGenePieces.subList(0, normalGeneTotalLength);
			homeoticGenePieces=containedGenePieces.subList(normalGeneTotalLength, normalGeneTotalLength+homeoticGeneTotalLenth);
		} catch (IOException | ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	private void writeObject(ObjectOutputStream out){
		try {
			out.writeInt(normalGeneHeaderLength);
			out.writeInt(normalGeneLength);
			out.writeInt(normalGeneNumber);
			out.writeInt(homeoticGeneHeaderLength);
			out.writeInt(homeoticGeneLength);
			out.writeInt(homeoticGeneNumber);
			out.writeObject(containedGenePieces);
			out.writeObject(normalGeneList);
			out.writeObject(homeoticGeneList);
			out.writeFloat(fitness);
			out.writeInt(selectedHomeoticGeneNumber);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	@Override
	public Individual copy() {
		// TODO Auto-generated method stub
		Individual individual=new Individual();
		List<GenePiece> copiedAllGenePieces=new ArrayList<GenePiece>(containedGenePieces.size());
		for(GenePiece genePiece:containedGenePieces)
			copiedAllGenePieces.add(genePiece.clone());
		individual.setContainedGenePieces(copiedAllGenePieces, normalGeneNumber, normalGeneHeaderLength, normalGeneLength, homeoticGeneNumber, homeoticGeneHeaderLength, homeoticGeneLength);
		individual.setFitness(fitness);
		individual.setSelectedHomeoticGeneNumber(selectedHomeoticGeneNumber);
		return individual;
	}
}
domain\core\algmodel\configuration\Population.java
package domain.core.algmodel.configuration;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import common.ICopy;
/**
 * 种群实体类
 * @author 申远
 *
 */
public class Population implements Serializable,ICopy<Population>{
	/**
	 * 
	 */
	private static final long serialVersionUID = -7369251203166977601L;
	private int size;
	private List<Individual> individuals;
	private long generation;
	/**
	 * 设置种群所包含的个体
	 * @param individuals 种群中个体的List
	 */
	public void setIndividuals(List<Individual> individuals) {
		this.individuals = individuals;
	}
	/**
	 * 创建一个种群，用户需要提供种群大小
	 * @param size 种群大小
	 */
	public Population(int size){
		this.size=size;
		individuals=new ArrayList<Individual>(size);
	}
	/**
	 * 创建种群，用户提供种群中所有个体组成的List
	 * @param popuList 包含有种群中所有个体的List
	 */
	public Population(List<Individual> popuList){
		this.individuals=popuList;
	}
	/**
	 * 返回种群中所有的个体
	 * @return 种群中所有个体组成的List
	 */
	public List<Individual> getIndividuals(){
		return individuals;
	}
	/**
	 * 返回种群中最优个体
	 * @return 种群中最优个体
	 */
	public Individual getBestIndividual(){
		Individual bestIndividual=individuals.get(0);
		for(Individual element:individuals)
			if(element.getFitness()>=bestIndividual.getFitness())
				bestIndividual=element;
		return bestIndividual;
	}
	/**
	 * 返回种群中最差个体
	 * @return 种群中最差个体
	 */
	public Individual getWorstIndividual(){
		Individual bestIndividual=individuals.get(0);
		for(Individual element:individuals)
			if(element.getFitness()<=bestIndividual.getFitness())
				bestIndividual=element;
		return bestIndividual;
	}
	/**
	 * 返回当前种群的代数，即当前种群是第几代种群
	 * @return 当前种群的代数
	 */
	public long getGeneration(){
		return generation;
	}
	/**
	 * 设置当前种群的代数，即设置当前种群是第几代种群
	 * @param generation 当前种群的代数
	 */
	public void setGeneration(long generation) {
		this.generation = generation;
	}
	/**
	 * 向种群中添加个体
	 * @param individual 待添加的个体
	 */
	public void addIndividual(Individual individual){
		individuals.add(individual);
	}
	/**
	 * 对当前种群进行复制，产生一个新的种群，对于string 这样的不可改变对象和int这样的基本数据类型，这是一个浅复制，对于其他的对象而言，这是一个深度复制
	 * @return 一个新的种群，二者不共享内存空间，只是具有相同的初始化的值
	 */
	@Override
	public Population copy() {
		// TODO Auto-generated method stub
		Population population=new Population(size);
		population.setGeneration(generation);
		for(int i=0;i<individuals.size();i++)
			population.addIndividual(individuals.get(i).copy());
		return population;
	}
}
domain\core\algmodel\genecomponent\Computable.java
package domain.core.algmodel.genecomponent;
/**
 * 抽象类，表示当前实体可做为函数的参数，例如常数和变量
 * @author 申远
 *
 */
public abstract class Computable extends GenePiece{
	
	private static final long serialVersionUID = 8680281835665872726L;
}
domain\core\algmodel\genecomponent\Constant.java
package domain.core.algmodel.genecomponent;
import java.util.Random;
/**
 * 整型常数类，这个类主要用来做为同源基因中函数的
 * @author 申远
 *
 */
public class Constant extends Computable {
	private static final long serialVersionUID = 5428175735104183458L;
	/**
	 * 初始化整型常数类，初始化后此方法将自动生成value值，代表普通基因的编号
	 * @param max 普通基因的数量
	 */
	public Constant(int max){
		Random random=new Random();
		value=random.nextInt(max);
	}
	/**
	 * 整型常数值不可设定，请不要调用此方法，调用后程序会抛出异常
	 * @param value 设定常数值，此设定无效，而且会抛出异常
	 */
	@Deprecated
	@Override
	public void setValue(float value) {
		// TODO Auto-generated method stub
		throw new UnsupportedOperationException("整型常数类的值由程序自动生成，用户不能手动设置");
	}
	/**
	 * 整型的符号表示不可设定，请不要调用此方法，调用后程序会抛出异常
	 * @param symbol 设定符号表示，此设定无效，而且会抛出异常
	 */
	@Deprecated
	@Override
	public void setSymbol(String symbol) {
		// TODO Auto-generated method stub
		throw new UnsupportedOperationException("不能手动设定整型常数的符号表示，这个符号表示就是此整型常数的值，由程序自动生成");
	}
	/**
	 * 返回整型常数的符号表示，即为整型常数的值的符号表示
	 */
	@Override
	public String getSymbol() {
		return Integer.toString((int)value);
	}
	/**
	 * 返回整型常数的字符串表示，本方法将自动调用getSymbol方法
	 */
	@Override
	public String toString() {
		// TODO Auto-generated method stub
		return getSymbol();
	}
}
domain\core\algmodel\genecomponent\Function.java
package domain.core.algmodel.genecomponent;
import java.util.Deque;
/**
 * 函数抽象类，请确保任何继承此类的子类都具有默认构造函数，否则系统会出现错误
 */
public abstract class Function extends GenePiece{
	private static final long serialVersionUID = -5233529550458131848L;
	private final int arity;
	/**
	 * 构造函数，需要提供函数名，函数的符号表示，函数的目数
	 * @param name 函数名
	 * @param arity 函数的目数，即操作符数量，例如加法的目数为2，平方根的目数为1
	 * @param symbol 函数的符号表示
	 */
	public Function(String name,int arity,String symbol){
		value=Float.NaN;
		this.name=name;
		this.arity=arity;
		this.symbol=symbol;
	}
	/**
	 * 获得当前函数的目数
	 */
	public int getArity() {
		return arity;
	}
	/**
	 * 进行具体的函数运算，并返回运算结果
	 * @param operators 操作符队列，请使用LIFO的方式进行计算，否则系统将出错
	 * @return 函数进行运算后的返回值。
	 */
	public abstract float operate(Deque<Float> operators);
}
domain\core\algmodel\genecomponent\GenePiece.java
package domain.core.algmodel.genecomponent;
import java.io.Serializable;
import common.ICopy;
/**
 * 基因片段类，或称基因位类，在每一个头部或者尾部中，最终包含的都是此类GenePiece
 * @author 申远
 *
 */
public abstract class GenePiece implements Serializable,Cloneable,ICopy<GenePiece>{
	private static final long serialVersionUID = 7648117930489664221L;
	protected String symbol=new String();
	protected String name=new String();
	protected float value;
	/**
	 * 返回当前基因片段的符号表示，用String表示
	 * @return 基因片段符号表示
	 */
	public String getSymbol() {
		return symbol;
	}
	/**
	 * 设置当前基因片段的符号表示，用String表示
	 * @param symbol 基因片段符号表示
	 */
	public void setSymbol(String symbol) {
		this.symbol = symbol;
	}
	/**
	 * 返回当前基因片段的名称
	 * @return 基因片段名称的字符串表示
	 */
	public String getName(){
		return name;
	}
	/**
	 * 设置当前基因片段的名称
	 * @param name 当前基因片段的名称
	 */
	public void setName(String name){
		this.name=name;
	}
	/**
	 * 返回当前基因片段的名称表示，本方法将直接调用getName()。
	 */
	@Override
	public String toString() {
		// TODO Auto-generated method stub
		return getName();
	}
	/**
	 * 获得当前基因片段的值
	 * @return 当前基因片段的值
	 */
	public float getValue(){
		return value;
	}
	/**
	 * 设置当前基因片段的值
	 * @param value 基因片段的值
	 */
	public void setValue(float value){
		this.value=value;
	}
	/**
	 * 克隆一份当前对象，这个方法调用了Object中的clone方法。
	 * 这是一个深度克隆，即源对象和新对象具有相同的初值，但具有不同的内存地址。
	 */
	@Override
	public GenePiece clone(){
		// TODO Auto-generated method stub
		GenePiece o=null;
		try {
			o=(GenePiece) super.clone();
		} catch (CloneNotSupportedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return o;
	}
	@Override
	/**
	 * 这个copy方法将直接调用clone方法实现深度复制
	 */
	public GenePiece copy() {
		// TODO Auto-generated method stub
		return clone();
	}
}
domain\core\algmodel\genecomponent\Variable.java
package domain.core.algmodel.genecomponent;
/**
 * 变量类，用户输入的所有的变量信息都将变换为类
 * @author 申远
 *
 */
public class Variable extends Computable{
	private static final long serialVersionUID = 2304632426125416061L;
	/**
	 * 空构造函数，不进行任何操作
	 */
	public Variable() {
		// TODO Auto-generated constructor stub
	}
	/**
	 * 构造函数，用户可以指定变量名称
	 * @param name 变量名称
	 */
	public Variable(String name){
		this.name = name;
	}
}
domain\core\algmodel\individualcomponent\Gene.java
package domain.core.algmodel.individualcomponent;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.List;
import common.ICopy;
import domain.core.algmodel.genecomponent.GenePiece;
/**
 * 基因类，此类为抽象类，提供了基因的通用的信息
 * @author 申远
 *
 */
public abstract class Gene implements Serializable,ICopy<Gene> {
	private static final long serialVersionUID = 7104627974958183372L;
	private float value;
	private int start;
	private int end;
	private List<GenePiece> originalGenePiece;
	protected List<GenePiece> containedGenePieces;
	protected Header header;
	protected Tail tail;
	/**
	 * 构造函数,创建一个新的基因，用户需要在当前基因对应的个体的全部基因片段中指定当前基因从基因片段的哪里开始，哪里结束。
	 * @param origGenePieces 当前基因对应的个体中全部的基因片段
	 * @param start 当前基因在个体基因片段中开始的地方，包括这个地址
	 * @param end 当前基因在个体基因片段中结束的地方，不包括这个地址
	 */
	public Gene(List<GenePiece> origGenePieces,int start,int end){
		this.originalGenePiece=origGenePieces;
		this.start=start;
		this.end=end;
		containedGenePieces=origGenePieces.subList(start, end);
	}
	/**
	 * 返回当前基因的头部
	 * @return 当前基因的头部
	 */
	public abstract Header getHeader();
	/**
	 * 返回当前基因的尾部
	 * @return 当前基因的尾部
	 */
	public abstract Tail getTail();
	/**
	 * 返回当前基因的值，通过使用同源基因连接各个基因的值，可以求得个体对某个输入集的解，通过对解集进行某种数学变换，可以得到个体的适应值。
	 * @return 当前基因的值
	 */
	public float getValue() {
		return value;
	}
	/**
	 * 设置当前基因的值
	 * @param value 当前基因的值
	 */
	public void setValue(float value) {
		this.value = value;
	}
	/**
	 * 返回当前基因所对应的基因片段
	 * @return 包含当前基因所对应的基因片段的List
	 */
	public List<GenePiece> getContainedGenePieces(){
		return containedGenePieces;
	}
	@SuppressWarnings("unchecked")
	private void readObject(ObjectInputStream in){
		try {
			value=in.readFloat();
			start=in.readInt();
			end=in.readInt();
			originalGenePiece=(List<GenePiece>) in.readObject();
			containedGenePieces=originalGenePiece.subList(start, end);
			header=(Header) in.readObject();
			tail=(Tail) in.readObject();
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}catch(ClassNotFoundException e){
			e.printStackTrace();
		}
	}
	private void writeObject(ObjectOutputStream out){
		try {
			out.writeFloat(value);
			out.writeInt(start);
			out.writeInt(end);
			out.writeObject(originalGenePiece);
			out.writeObject(header);
			out.writeObject(tail);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	@Override
	public Gene copy(){
		// TODO Auto-generated method stub
		Gene gene=null;
		if(this instanceof NormalGene){
			NormalGene normalGene=(NormalGene)this;
			gene=new NormalGene(normalGene.getHeader().getContainedGenePieces().size(), normalGene.getTail().getContainedGenePieces().size(), originalGenePiece, start, end);
		}
		else if (this instanceof HomeoticGene) {
			HomeoticGene homeoticGene=(HomeoticGene)this;
			gene=new HomeoticGene(homeoticGene.getHeader().getContainedGenePieces().size(), homeoticGene.getTail().getContainedGenePieces().size(), originalGenePiece, start, end);
		}
		return gene;
	}
}
domain\core\algmodel\individualcomponent\Header.java
package domain.core.algmodel.individualcomponent;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.List;
import common.ICopy;
import domain.core.algmodel.genecomponent.GenePiece;
/**
 * 基因头部实体的基类，是个抽象类
 * @author 申远
 *
 */
public abstract class Header implements Serializable,ICopy<Header>{
	private static final long serialVersionUID = -4787817859125343269L;
	protected List<GenePiece> containedGenePieces;
	private List<GenePiece> genePieces;
	private int start;
	private int end;
	/**
	 * 创建基因头部的构造函数，用户需要提供个体或或者基因中的基因片段List，并确定头部从哪个地址开始，到哪个地址结束
	 * @param genePieces 基因片段List
	 * @param start 基因头部开始的地址，包括
	 * @param end 基因头部结束的地址，不包括
	 */
	public Header(List<GenePiece> genePieces,int start,int end){
		this.genePieces=genePieces;
		this.start=start;
		this.end=end;
		this.containedGenePieces=genePieces.subList(start, end);
	}
	/**
	 * 返回头部所包含的基因片段。
	 * @return 基因片段List
	 */
	public List<GenePiece> getContainedGenePieces(){
		return containedGenePieces;
	}
	@SuppressWarnings("unchecked")
	private void readObject(ObjectInputStream in){
		try {
			genePieces=(List<GenePiece>) in.readObject();
			start=in.readInt();
			end=in.readInt();
			containedGenePieces=genePieces.subList(start, end);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}catch(ClassNotFoundException e){
			e.printStackTrace();
		}
	}
	private void writeObject(ObjectOutputStream out){
		try {
			out.writeObject(genePieces);
			out.writeInt(start);
			out.writeInt(end);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	@Override
	public Header copy() {
		// TODO Auto-generated method stub
		Header header=null;
		if(this instanceof NormalGeneHeader){
			header=new NormalGeneHeader(genePieces, start, end);
		}
		else if(this instanceof HomeoticGeneHeader) {
			header=new HomeoticGeneHeader(genePieces, start, end);
		}
		return header;
	}
}
domain\core\algmodel\individualcomponent\HomeoticGene.java
package domain.core.algmodel.individualcomponent;
import java.util.List;
import domain.core.algmodel.genecomponent.GenePiece;
/**
 * 同源基因实体类
 * @author 申远
 * 
 */
public class HomeoticGene extends Gene{
	private static final long serialVersionUID = 4297205056477494966L;
	/**
	 * 创建同源基因的构造函数，用户需要在当前基因对应的个体的全部基因片段中指定当前基因从基因片段的哪里开始，哪里结束。
	 * @param headerLength 同源基因的头部长度
	 * @param tailLength 同源基因的尾部长度
	 * @param genePieces 个体中所包含的全部基因片段
	 * @param start 当前基因在个体基因片段中开始的地方，包括这个地址
	 * @param end 当前基因在个体基因片段中结束的地方，不包括这个地址
	 */
	public HomeoticGene(int headerLength,int tailLength,List<GenePiece> genePieces,int start,int end){
		super(genePieces,start,end);
		header=new HomeoticGeneHeader(genePieces,start,start+headerLength);
		tail=new HomeoticGeneTail(genePieces,start+headerLength, end);
	}
	@Override
	public HomeoticGeneHeader getHeader() {
		// TODO Auto-generated method stub
		return (HomeoticGeneHeader) header;
	}
	@Override
	public HomeoticGeneTail getTail() {
		// TODO Auto-generated method stub
		return (HomeoticGeneTail) tail;
	}
}
domain\core\algmodel\individualcomponent\HomeoticGeneHeader.java
package domain.core.algmodel.individualcomponent;
import java.util.List;
import domain.core.algmodel.genecomponent.GenePiece;
/**
 * 同源基因头部的实体类
 * @author 申远
 *
 */
public class HomeoticGeneHeader extends Header{
	private static final long serialVersionUID = 5276198147420739676L;
	/**
	 * 创建基因头部的构造函数，用户需要提供个体或或者基因中的基因片段List，并确定头部从哪个地址开始，到哪个地址结束
	 * @param genePieces 基因片段List
	 * @param start 基因头部开始的地址，包括
	 * @param end 基因头部结束的地址，不包括
	 */
	public HomeoticGeneHeader(List<GenePiece> genePieces,int start,int end) {
		// TODO Auto-generated constructor stub
		super(genePieces,start,end);
	}
	
}
domain\core\algmodel\individualcomponent\HomeoticGeneTail.java
package domain.core.algmodel.individualcomponent;
import java.util.List;
import domain.core.algmodel.genecomponent.GenePiece;
/**
 * 同源基因尾部实体类
 * @author 申远
 *
 */
public class HomeoticGeneTail extends Tail{
	private static final long serialVersionUID = -3919750383832279100L;
	/**
	 * 创建基因尾部的构造函数，用户需要提供个体或或者基因中的基因片段List，并确定头部从哪个地址开始，到哪个地址结束
	 * @param genePieces 基因片段List
	 * @param start 基因头部开始的地址，包括
	 * @param end 基因头部结束的地址，不包括
	 */
	public HomeoticGeneTail(List<GenePiece> genePieces,int start,int end) {
		super(genePieces,start,end);
		// TODO Auto-generated constructor stub
	}
}
domain\core\algmodel\individualcomponent\NormalGene.java
package domain.core.algmodel.individualcomponent;
import java.util.List;
import domain.core.algmodel.genecomponent.GenePiece;
/**
 * 普通基因实体类
 * @author 申远
 *
 */
public class NormalGene extends Gene{
	private static final long serialVersionUID = -4798878563976876499L;
	/**
	 * 创建普通基因的构造函数，用户需要在当前基因对应的个体的全部基因片段中指定当前基因从基因片段的哪里开始，哪里结束。
	 * @param headerLength 普通基因的头部长度
	 * @param tailLength 普通基因的尾部长度
	 * @param genePieces 个体中所包含的全部基因片段
	 * @param start 当前基因在个体基因片段中开始的地方，包括这个地址
	 * @param end 当前基因在个体基因片段中结束的地方，不包括这个地址
	 */
	public NormalGene(int headerLength,int tailLength,List<GenePiece> genePieces,int start,int end){
		super(genePieces,start,end);
		header=new NormalGeneHeader(genePieces,start,start+headerLength);
		tail=new NormalGeneTail(genePieces,start+headerLength, end);
	}
	@Override
	public NormalGeneHeader getHeader() {
		// TODO Auto-generated method stub
		return (NormalGeneHeader) header;
	}
	@Override
	public NormalGeneTail getTail() {
		// TODO Auto-generated method stub
		return (NormalGeneTail) tail;
	}
}
domain\core\algmodel\individualcomponent\NormalGeneHeader.java
package domain.core.algmodel.individualcomponent;
import java.util.List;
import domain.core.algmodel.genecomponent.GenePiece;
/**
 * 普通基因头部的实体类
 * @author 申远
 *
 */
public class NormalGeneHeader extends Header {
	private static final long serialVersionUID = 6872200051330701939L;
	/**
	 * 创建基因头部的构造函数，用户需要提供个体或或者基因中的基因片段List，并确定头部从哪个地址开始，到哪个地址结束
	 * @param genePieces 基因片段List
	 * @param start 基因头部开始的地址，包括
	 * @param end 基因头部结束的地址，不包括
	 */
	public NormalGeneHeader(List<GenePiece> genePieces,int start,int end) {
		super(genePieces,start,end);
		// TODO Auto-generated constructor stub
	}
}
domain\core\algmodel\individualcomponent\NormalGeneTail.java
package domain.core.algmodel.individualcomponent;
import java.util.List;
import domain.core.algmodel.genecomponent.GenePiece;
/**
 * 普通基因尾部的实体类
 * @author 申远
 *
 */
public class NormalGeneTail extends Tail {
	private static final long serialVersionUID = -3087000575324792050L;
	/**
	 * 创建基因尾部的构造函数，用户需要提供个体或或者基因中的基因片段List，并确定头部从哪个地址开始，到哪个地址结束
	 * @param genePieces 基因片段List
	 * @param start 基因头部开始的地址，包括
	 * @param end 基因头部结束的地址，不包括
	 */
	public NormalGeneTail(List<GenePiece> genePieces,int start,int end) {
		super(genePieces,start,end);
		// TODO Auto-generated constructor stub
	}
}
domain\core\algmodel\individualcomponent\Tail.java
package domain.core.algmodel.individualcomponent;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.List;
import common.ICopy;
import domain.core.algmodel.genecomponent.Computable;
import domain.core.algmodel.genecomponent.GenePiece;
/**
 * 基因尾部实体的基类，是一个抽象类
 * @author 申远
 *
 */
public abstract class Tail implements Serializable,ICopy<Tail>{
	private static final long serialVersionUID = -4667068182615591355L;
	protected List<Computable> computable;
	private List<GenePiece> genePieces;
	private int start;
	private int end;
	/**
	 * 创建基因尾部的构造函数，用户需要提供个体或或者基因中的基因片段List，并确定头部从哪个地址开始，到哪个地址结束
	 * @param genePieces 基因片段List
	 * @param start 基因头部开始的地址，包括
	 * @param end 基因头部结束的地址，不包括
	 */
	@SuppressWarnings("unchecked")
	public Tail(List<GenePiece> genePieces,int start,int end){
		this.genePieces=genePieces;
		this.start=start;
		this.end=end;
		this.computable=(List<Computable>)(Object)genePieces.subList(start, end);
	}
	/**
	 * 基因尾部所包含的全部基因片段
	 * @return 包含有尾部基因片段的List
	 */
	public List<Computable> getContainedGenePieces(){
		return computable;
	}
	@SuppressWarnings("unchecked")
	private void readObject(ObjectInputStream in){
		try {
			genePieces=(List<GenePiece>) in.readObject();
			start=in.readInt();
			end=in.readInt();
			computable=(List<Computable>)(Object)genePieces.subList(start, end);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}catch(ClassNotFoundException e){
			e.printStackTrace();
		}
	}
	private void writeObject(ObjectOutputStream out){
		try {
			out.writeObject(genePieces);
			out.writeInt(start);
			out.writeInt(end);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	@Override
	public Tail copy() {
		// TODO Auto-generated method stub
		Tail tail=null;
		if(this instanceof NormalGeneTail){
			tail=new NormalGeneTail(genePieces, start, end);
		}
		else if (this instanceof HomeoticGeneTail) {
			tail=new HomeoticGeneTail(genePieces, start, end);
		}
		return tail;
	}
}
domain\core\inputmodel\DataColumn.java
package domain.core.inputmodel;
public class DataColumn {
   
	
	private boolean readOnly;//只读
    private DataTable table;//dataTable的引用
    private String columnName;//列名
    private String captionName;//显示名称
    private int columnIndex;//列索引
    private int dataType;//数据类型名称
    public DataColumn(){
    	this("default1");
    }
    public DataColumn(int dataType){
    	this("default1",dataType);
    }
    public DataColumn(String columnName){
    	this(columnName,0);
    	
    }
    public DataColumn(String columnName,int dataType){
    	this.setDataType(dataType);
    	this.columnName=columnName;
    }
    public boolean isReadOnly() {
		return readOnly;
	}
	public void setReadOnly(boolean readOnly) {
		this.readOnly = readOnly;
	}
	public DataTable getTable() {
		return table;
	}
	public void setTable(DataTable table) {
		this.table = table;
	}
	public String getColumnName() {
		return columnName;
	}
	public void setColumnName(String columnName) {
		this.columnName = columnName;
	}
	public String getCaptionName() {
		return captionName;
	}
	public void setCaptionName(String captionName) {
		this.captionName = captionName;
	}
	public int getColumnIndex() {
		return columnIndex;
	}
	public void setColumnIndex(int columnIndex) {
		this.columnIndex = columnIndex;
	}
	public int getDataType() {
		return dataType;
	}
	public void setDataType(int dataType) {
		this.dataType = dataType;
	}
	
	public Object convertTo(Object value){
		return value;
		
	}
	public String toString(){
		return this.columnName;
	}
}
domain\core\inputmodel\DataColumnCollection.java
package domain.core.inputmodel;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import domain.core.algmodel.genecomponent.Variable;
public class DataColumnCollection {
	List<DataColumn> columns;
	HashMap<String, DataColumn> nameMap;
	
	List<Variable> variableList = new ArrayList<Variable>();
	public DataColumnCollection() {
		columns = new ArrayList<DataColumn>();
		nameMap = new HashMap<String, DataColumn>();
	}
	public DataColumnCollection(List<DataColumn> columns,
			HashMap<String, DataColumn> nameMap) {
		this.columns = columns;
		this.nameMap = nameMap;
	}
	public void add(int index, DataColumn column) {
		if (index < columns.size())
			columns.add(index, column);
		else
			columns.add(columns.size(), column);
		
		
		
		variableList.add(new Variable(column.getColumnName()));
		
		
	}
	public void add(DataColumn column) {
		
		columns.add(column);
		variableList.add(new Variable(column.getColumnName()));
	}
	public void add(Object obj) {
		
		DataColumn column = (DataColumn) obj;
		columns.add(column);
		variableList.add(new Variable(column.getColumnName()));
	}
	public DataColumn addColumn(String columnName, int dataType) {
		DataColumn column = new DataColumn(columnName, dataType);
		nameMap.put(columnName, column);
		columns.add(column);
		variableList.add(new Variable(column.getColumnName()));
		return column;
	}
	public void addColumn(String columnName) {
		DataColumn column = new DataColumn(columnName);
		nameMap.put(columnName, column);
		columns.add(column);
		variableList.add(new Variable(column.getColumnName()));
	}
	
	
	public DataColumn get(int index) {
		return columns.get(index);
	}
	public DataColumn get(String columnName) {
		return nameMap.get(columnName);
	}
	public int size() {
		// TODO Auto-generated method stub
		return columns.size();
	}
	
	
	public List<Variable> getVariableList(){
		return variableList;
	}
}
domain\core\inputmodel\DataRow.java
package domain.core.inputmodel;
import java.util.LinkedHashMap;
import java.util.Map;
public class DataRow {
	private int rowIndex = -1;// 定义该行记录在table所处的行数
	private DataColumnCollection columns;
	public void setTable(DataTable table) {
		this.table = table;
		this.columns = table.getColumns();
	}
	public void setItemMap(Map<String, Object> itemMap) {
		this.itemMap = itemMap;
	}
	private DataTable table; // table的一个引用
	private Map<String, Object> itemMap = new LinkedHashMap<String, Object>();
	// 用于存储数据的Map对象，这里保存的对象不包括顺序信息，数据获取的索引通过行信息标识
	public DataRow() {
	}
	public DataRow(DataTable table) {
		this.table = table;
		this.columns = table.getColumns();
	}
	// 获取当前行所属的数据表对象
	public DataTable getTable() {
		return this.table;
	}
	public DataColumnCollection getColumns() {
		return columns;
	}
	public void setColumns(DataColumnCollection columns) {
		this.columns = columns;
	}
	public void setValue(String columnName, Object value) {
		setValue(this.columns.get(columnName), value);
	}
	public void setValue(DataColumn column, Object value) {
		if (column != null) {
			String lowerColumnName = column.getColumnName().toLowerCase();
			if (getItemMap().containsKey(lowerColumnName))
				getItemMap().remove(lowerColumnName);
			getItemMap().put(lowerColumnName, column.convertTo(value));
		}
	}
	public Object getValue(int index) {
		String colName = this.columns.get(index).getColumnName().toLowerCase();
		return this.getItemMap().get(colName);
	}
	public Object getValue(String columnName) {
		return this.getItemMap().get(columnName.toLowerCase());
	}
	public Map<String, Object> getItemMap() {
		return itemMap;
	}
	public void setRowIndex(int rowIndex) {
		this.rowIndex = rowIndex;
	}
	public void setValue(int col, Object value) {
		String lowerColumnName = this.columns.get(col).getColumnName()
				.toLowerCase();
		if (getItemMap().containsKey(lowerColumnName))
			getItemMap().remove(lowerColumnName);
		getItemMap().put(lowerColumnName, columns.get(col).convertTo(value));
	}
	public int getRowIndex() {
		return rowIndex;
	}
	/*
	 * public void copyFrom(DataRow row) { this.itemMap.clear();//首先请客当前记录 for
	 * (Object c : this.columns) { this.itemMap.put(c.toString().toLowerCase(),
	 * row.getValue(c.toString())); } }
	 */
}
domain\core\inputmodel\DataRowCollection.java
package domain.core.inputmodel;
import java.util.ArrayList;
import java.util.List;
public class DataRowCollection {
	DataColumnCollection columns;
	List<DataRow> dataRows;
	public DataRowCollection() {
		columns = new DataColumnCollection();
		dataRows = new ArrayList<DataRow>();
	}
	public DataRowCollection(List<DataRow> rows, DataColumnCollection columns) {
		this.columns = columns;
		this.dataRows = rows;
	}
	public void add(int index, DataRow row) {
		if (index < dataRows.size())
			dataRows.add(index, row);
		else
			dataRows.add(dataRows.size(), row);
	}
	public void add(DataRow row) {
		dataRows.add(row);
	}
	public void add(Object obj) {
		dataRows.add((DataRow) obj);
	}
	public void add(int index, Object obj) {
		dataRows.add(index, (DataRow) obj);
	}
	public int size() {
		return dataRows.size();
	}
	public DataRow get(int index) {
		return dataRows.get(index);
	}
	public void setColumns(DataColumnCollection columns2) {
		this.columns = columns2;
	}
}
domain\core\inputmodel\DataTable.java
package domain.core.inputmodel;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
public final class DataTable {
	
	/**
	 * 保存行的集合
	 * 用来保存DataRowCollection的集合
	 */
	private DataRowCollection rows; 
	
	/**
	 * 保存列的集合
	 * 用于保存DataColumn的对象
	 */
	private DataColumnCollection columns; 
	
	/**
	 * 保存Table的名字
	 */
	private String tableName; //表名
	
	/**
	 * 设置是否只读
	 * 默认false
	 */
    private boolean readOnly = false;
    
    /**
     * 下一行的引用
     * 初始值为0
     */
	private int nextRowIndex = 0;
	
	/**
	 * 标记对象
	 */
	private Object tag;
	
	/**
	 * 默认的构造函数
	 * 初始化 行的集合、列的集合
	 */
	public DataTable() {
		  this.columns = new DataColumnCollection();
		  this.rows = new DataRowCollection();
		  this.rows.setColumns(columns);
    }
	
	/**
	 * 设置表的名称
	 * @param dataTableName
	 */
	public DataTable(String dataTableName) {
          this();
		  this.tableName = dataTableName;
    }
	
	
	/**
	 * 获取中的行数
	 * @return
	 */
	public int getTotalCount() {
          return rows.size();
	} 
	
	
	/**
	 * 判断是否只读
	 * @return
	 */
    public boolean isReadOnly() {
		  return this.readOnly;
    }   
    
    /**
     * 设置是否只读
     * @param readOnly
     */
	public void setReadOnly(boolean readOnly) {
		  this.readOnly = readOnly;
	}
	
	/**
	 * 获取表名
	 * @return
	 */
	public String getTableName() {
         return this.tableName;
	}
	
	/**
	 * 设置表名
	 * @param tableName
	 */
    public void setTableName(String tableName) {
        this.tableName = tableName;
	}
    
    
    /**
     * 获得行的集合
     * @return
     */
    public DataRowCollection getRows() {
            return this.rows;
     }
    
    /**
     * 获得列的集合
     * @return
     */
    public DataColumnCollection getColumns() {
    	    return this.columns;
    }
    
    
    
    /**
     * 获取给定行号的给定列名的值
     * @param row	行号
     * @param colName	列名
     * @return
     */
    public Object getValue(int row,String colName) {
    		return this.rows.get(row).getValue(colName);
    }
    
    
    
    /**
     * 获取给定行号和列号的值
     * @param row	行号
     * @param col	列号
     * @return
     */
    public Object getValue(int row,int col) {
    	     return this.rows.get(row).getValue(col);
    }
    
    
    /**
     * 添加新的一行
     * @return
     * @throws Exception
     */
    public DataRow newRow() throws Exception {
             DataRow tempRow = new DataRow(this);
             nextRowIndex = nextRowIndex < this.rows.size() ? this.rows.size(): nextRowIndex;
    	     tempRow.setColumns(this.columns);
    	     tempRow.setRowIndex(nextRowIndex++);
    	     return tempRow;      
    }
    
    
    /**
     * 根据行号和列号设定某一单元格的值
     * @param row
     * @param col	行号
     * @param value
     */
    public void setValue(int row,int col,Object value) {
             this.rows.get(row).setValue(col, value);
    }
       
    /**
     * 根据行号和列名设置单元格的值
     * @param row
     * @param colName	行名
     * @param value
     */
    public void setValue(int row,String colName,Object value) {
    		 this.rows.get(row).setValue(colName, value);
    }
    
    
    
    public Object getTag() {
		return tag;
	}
	public void setTag(Object tag) {
		this.tag = tag;
	}
	
	
	/**
	 * 添加新的一列，为新的一列指定列名
	 * 返回该行的实例
	 * @param columnName
	 * @param dataType
	 * @return
	 * @throws Exception
	 */
	public DataColumn addColumn(String columnName,
        int dataType) throws Exception {
		return this.columns.addColumn(columnName, dataType);
	}
	
	
	/**
	 * 添加新的一行
	 * @param row
	 * @throws Exception
	 */
	public void addRow(DataRow row) throws Exception {
		if (row.getRowIndex() > this.rows.size())
		    row.setRowIndex(this.rows.size());
			 this.rows.add(row);
	}
	
	
	/**
	 * 获取某一列
	 * @param index
	 * @return
	 */
    public String getColumnName(int index){
		return columns.get(index).getColumnName();
    }
    
    
    
   public String getColumnName(Object obj){
	 for(int i=0;i<this.rows.size();i++){
	     DataRow row=this.rows.get(i);
	     //System.out.println("ww"+row.getValue(i));
	     for(int j=0;j<this.columns.size();j++){
	    	 Object obj2=this.getValue(i, j);
	    	 //System.out.println("obj2"+obj2.toString()+"  "+obj.toString());
	    	 if(obj2.toString().equals(obj.toString())){
		    	  return row.getColumns().get(j).getColumnName().toLowerCase();
		     }
	     }
	   }	
	 return "没有找到";		
   }
   
   
   
   //根据列的index得到列值
   public <T>  List<T> getColumnValue(int index){
	   	List<T> valueList=new ArrayList<T>();
	   	String columnName=this.getColumns().get(index).getColumnName();
   		for(int i=0;i<this.getRows().size();i++){
   			valueList.add((T) this.getValue(i,columnName));
		}
   		return valueList;
   }
   /* Iterator it=columns.nameMap.entrySet().iterator();
    * while(it.hasNext()){
		Entry entry=(Entry) it.next();
		System.out.println("ww"+entry.getKey());
		if(entry.getValue().equals(obj)){
			return (String) entry.getKey();
		}
		
	}*/
   
   
   /**
    * 添加新的一行
    * @param columnName
    */
public void addColumn(String  columnName) {
	this.columns.addColumn(columnName);
	
}
}
domain\core\outputmodel\AlgInstance.java
package domain.core.outputmodel;
import java.io.Serializable;
import java.util.Set;
public class AlgInstance implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = -1368598667691715099L;
	private Long id;
	private Long runTimes;
	private Long totalGeneration;
	private GepConfiguration gepConfiguration;
	private Set<OutputPopulation> populationSet;
	public Long getId() {
		return id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public Long getRunTimes() {
		return runTimes;
	}
	public void setRunTimes(Long runTimes) {
		this.runTimes = runTimes;
	}
	public Long getTotalGeneration() {
		return totalGeneration;
	}
	public void setTotalGeneration(Long totalGeneration) {
		this.totalGeneration = totalGeneration;
	}
	public GepConfiguration getGepConfiguration() {
		return gepConfiguration;
	}
	public void setGepConfiguration(GepConfiguration gepConfiguration) {
		this.gepConfiguration = gepConfiguration;
	}
	public Set<OutputPopulation> getPopulationSet() {
		return populationSet;
	}
	public void setPopulationSet(Set<OutputPopulation> populationSet) {
		this.populationSet = populationSet;
	}
	public void addPopulation(OutputPopulation population){
		populationSet.add(population);
	}
}
domain\core\outputmodel\BestIndividual.java
package domain.core.outputmodel;
/**
 * BestIndividual entity. @author MyEclipse Persistence Tools
 */
public class BestIndividual  implements java.io.Serializable {
    // Fields    
     /**
	 * 
	 */
	private static final long serialVersionUID = -3893835633459421563L;
	/**
	 * 
	 */
	
	
	private Long id;
    private byte[] individual;
   // private AlgInstance algInstance;
    // Constructors
    /** default constructor */
    public BestIndividual() {
    }
    
    public BestIndividual(byte[] individual) {
        this.individual = individual;
    }
    
    
    /** full constructor 
    public BestIndividual(byte[] individual, AlgInstance algInstance) {
        this.individual = individual;
        this.algInstance = algInstance;
    }*/
   
    // Property accessors
    public Long getId() {
        return this.id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    public byte[] getIndividual() {
        return this.individual;
    }
    
    public void setIndividual(byte[] individual) {
        this.individual = individual;
    }
/*
    public AlgInstance getAlgInstance() {
        return this.algInstance;
    }
    
    public void setAlgInstance(AlgInstance algInstance) {
        this.algInstance = algInstance;
    }
   */
}
domain\core\outputmodel\GepConfiguration.java
package domain.core.outputmodel;
import java.io.Serializable;
public class GepConfiguration implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = 3397525135819808968L;
	/**
	 * 
	 */
	private Long id;
	private String name;
	private String inputFile;
	private String populationSize;
	private String normalGeneNumber;
	private String homeoticGeneNumber;
	private String normalHeaderLength;
	private String homeoticHeaderLength;
	private String randomConstantStart;
	private String randomConstantEnd;
	private String constantListSize;
	private String creator;
	private String calculator;
	private String selectionRange;
	private String accuray;
	private String maxGeneration;
	private String functionList;
	private String selector;
	private String modify;
	private String mutateRate;
	private String isTransportRate;
	private String isElement;
	private String risTransportRate;
	private String risElement;
	private String geneTransportRate;
	private String onePointRecombineRate;
	private String twoPointRecombineRate;
	private String geneRecombineRate;
	public GepConfiguration(){
		
	}
	public Long getId() {
		return id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getInputFile() {
		return inputFile;
	}
	public void setInputFile(String inputFile) {
		this.inputFile = inputFile;
	}
	public String getPopulationSize() {
		return populationSize;
	}
	public void setPopulationSize(String populationSize) {
		this.populationSize = populationSize;
	}
	public String getNormalGeneNumber() {
		return normalGeneNumber;
	}
	public void setNormalGeneNumber(String normalGeneNumber) {
		this.normalGeneNumber = normalGeneNumber;
	}
	public String getHomeoticGeneNumber() {
		return homeoticGeneNumber;
	}
	public void setHomeoticGeneNumber(String homeoticGeneNumber) {
		this.homeoticGeneNumber = homeoticGeneNumber;
	}
	public String getNormalHeaderLength() {
		return normalHeaderLength;
	}
	public void setNormalHeaderLength(String normalHeaderLength) {
		this.normalHeaderLength = normalHeaderLength;
	}
	public String getHomeoticHeaderLength() {
		return homeoticHeaderLength;
	}
	public void setHomeoticHeaderLength(String homeoticHeaderLength) {
		this.homeoticHeaderLength = homeoticHeaderLength;
	}
	public String getRandomConstantStart() {
		return randomConstantStart;
	}
	public void setRandomConstantStart(String randomConstantStart) {
		this.randomConstantStart = randomConstantStart;
	}
	public String getRandomConstantEnd() {
		return randomConstantEnd;
	}
	public void setRandomConstantEnd(String randomConstantEnd) {
		this.randomConstantEnd = randomConstantEnd;
	}
	public String getConstantListSize() {
		return constantListSize;
	}
	public void setConstantListSize(String constantListSize) {
		this.constantListSize = constantListSize;
	}
	public String getCreator() {
		return creator;
	}
	public void setCreator(String creator) {
		this.creator = creator;
	}
	public String getCalculator() {
		return calculator;
	}
	public void setCalculator(String calculator) {
		this.calculator = calculator;
	}
	public String getSelectionRange() {
		return selectionRange;
	}
	public void setSelectionRange(String selectionRange) {
		this.selectionRange = selectionRange;
	}
	public String getAccuray() {
		return accuray;
	}
	public void setAccuray(String accuray) {
		this.accuray = accuray;
	}
	public String getMaxGeneration() {
		return maxGeneration;
	}
	public void setMaxGeneration(String maxGeneration) {
		this.maxGeneration = maxGeneration;
	}
	public String getFunctionList() {
		return functionList;
	}
	public void setFunctionList(String functionList) {
		this.functionList = functionList;
	}
	public String getSelector() {
		return selector;
	}
	public void setSelector(String selector) {
		this.selector = selector;
	}
	public String getModify() {
		return modify;
	}
	public void setModify(String modify) {
		this.modify = modify;
	}
	public String getMutateRate() {
		return mutateRate;
	}
	public void setMutateRate(String mutateRate) {
		this.mutateRate = mutateRate;
	}
	public String getIsTransportRate() {
		return isTransportRate;
	}
	public void setIsTransportRate(String isTransportRate) {
		this.isTransportRate = isTransportRate;
	}
	public String getIsElement() {
		return isElement;
	}
	public void setIsElement(String isElement) {
		this.isElement = isElement;
	}
	public String getRisTransportRate() {
		return risTransportRate;
	}
	public void setRisTransportRate(String risTransportRate) {
		this.risTransportRate = risTransportRate;
	}
	public String getRisElement() {
		return risElement;
	}
	public void setRisElement(String risElement) {
		this.risElement = risElement;
	}
	public String getGeneTransportRate() {
		return geneTransportRate;
	}
	public void setGeneTransportRate(String geneTransportRate) {
		this.geneTransportRate = geneTransportRate;
	}
	public String getOnePointRecombineRate() {
		return onePointRecombineRate;
	}
	public void setOnePointRecombineRate(String onePointRecombineRate) {
		this.onePointRecombineRate = onePointRecombineRate;
	}
	public String getTwoPointRecombineRate() {
		return twoPointRecombineRate;
	}
	public void setTwoPointRecombineRate(String twoPointRecombineRate) {
		this.twoPointRecombineRate = twoPointRecombineRate;
	}
	public String getGeneRecombineRate() {
		return geneRecombineRate;
	}
	public void setGeneRecombineRate(String geneRecombineRate) {
		this.geneRecombineRate = geneRecombineRate;
	}
	public static long getSerialversionuid() {
		return serialVersionUID;
	}
	@Override
	public int hashCode() {
		// TODO Auto-generated method stub
		return 1;
	}
	@Override
	public boolean equals(Object obj) {
		// TODO Auto-generated method stub
		GepConfiguration compared=(GepConfiguration)obj;
		if(getAccuray().equals(compared.getAccuray()))
			if(getCalculator().equals(compared.getCalculator()))
					if(getCreator().equals(compared.getCreator()))
						if(getFunctionList().equals(compared.getFunctionList()))
							if(getGeneRecombineRate().equals(compared.getGeneRecombineRate()))
								if(getGeneTransportRate().equals(compared.getGeneTransportRate()))
									if(getHomeoticGeneNumber().equals(compared.getHomeoticGeneNumber()))
										if(getHomeoticHeaderLength().equals(compared.getHomeoticHeaderLength()))
											if(getIsElement().equals(compared.getIsElement()))
												if(getIsTransportRate().equals(compared.getIsTransportRate()))
													if(getMaxGeneration().equals(compared.getMaxGeneration()))
														if(getModify().equals(compared.getModify()))
															if(getMutateRate().equals(compared.getMutateRate()))
																if(getNormalGeneNumber().equals(compared.getNormalGeneNumber()))
																	if(getNormalHeaderLength().endsWith(compared.getNormalHeaderLength()))
																		if(getOnePointRecombineRate().equals(compared.getOnePointRecombineRate()))
																			if(getPopulationSize().equals(compared.getPopulationSize()))
																						if(getRisElement().equals(compared.getRisElement()))
																							if(getRisTransportRate().equals(compared.getRisTransportRate()))
																								if(getSelectionRange().equals(compared.getSelectionRange()))
																									if(getSelector().equals(compared.getSelector()))
																										if(getTwoPointRecombineRate().equals(compared.getTwoPointRecombineRate()))
																											if(getName().equals(compared.getName()))
																												return true;
		return false;
	}
	@Override
	public String toString() {
		// TODO Auto-generated method stub
		return name;
	}
}
domain\core\outputmodel\OutputIndividual.java
package domain.core.outputmodel;
import java.io.Serializable;
public class OutputIndividual implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = -816734522140044494L;
	private Long id;
	private Float fitness;
	private String expression;
	public Long getId() {
		return id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public Float getFitness() {
		return fitness;
	}
	public void setFitness(Float fitness) {
		this.fitness = fitness;
	}
	public String getExpression() {
		return expression;
	}
	public void setExpression(String expression) {
		this.expression = expression;
	}
}
domain\core\outputmodel\OutputPopulation.java
package domain.core.outputmodel;
import java.io.Serializable;
import java.util.Iterator;
import java.util.Set;
public class OutputPopulation implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = -6666071241631918798L;
	private long id;
	private long generation;
	private Set<OutputIndividual> indvididualSet;
	public long getId() {
		return id;
	}
	public void setId(long id) {
		this.id = id;
	}
	public Set<OutputIndividual> getIndvididualSet() {
		return indvididualSet;
	}
	public void setIndvididualSet(Set<OutputIndividual> indvididualSet) {
		this.indvididualSet = indvididualSet;
	}
	public long getGeneration() {
		return generation;
	}
	public void setGeneration(long generation) {
		this.generation = generation;
	}
	public OutputIndividual getBestOutputIndividual(){
		Iterator<OutputIndividual> individualIterator=indvididualSet.iterator();
		OutputIndividual bestIndividual=null;
		if(individualIterator.hasNext())
			bestIndividual=individualIterator.next();
		OutputIndividual temp;
		while(individualIterator.hasNext()){
			temp=individualIterator.next();
			if(temp.getFitness()>bestIndividual.getFitness())
				bestIndividual=temp;
		}
		return bestIndividual; 
	}
	public OutputIndividual getWorstOutputIndividual(){
		Iterator<OutputIndividual> individualIterator=indvididualSet.iterator();
		OutputIndividual worstIndividual=null;
		if(individualIterator.hasNext())
			worstIndividual=individualIterator.next();
		OutputIndividual temp;
		while(individualIterator.hasNext()){
			temp=individualIterator.next();
			if(temp.getFitness()<worstIndividual.getFitness())
				worstIndividual=temp;
		}
		return worstIndividual; 
	}
}
domain\iservice\IgepAlgService.java
package domain.iservice;
import java.io.IOException;
import java.util.List;
import jxl.read.biff.BiffException;
import domain.core.algmodel.configuration.GepAlgorithm;
import domain.core.algmodel.genecomponent.Function;
import domain.core.outputmodel.AlgInstance;
import domain.core.outputmodel.GepConfiguration;
import domain.service.alg.configuration.Calculator;
import domain.service.alg.configuration.Creator;
import domain.service.alg.configuration.Modifying;
import domain.service.alg.configuration.Selector;
import exception.Duplicated;
public interface IgepAlgService {
	public List<GepConfiguration> readArgumentsFromDb();
	public void setParameters(GepConfiguration myConfiguration) throws InstantiationException, IllegalAccessException, ClassNotFoundException, BiffException, IOException;
	public void saveArgumentsToDb(GepConfiguration myParameter) throws Duplicated;//这个异常是由于某种原因无法保存到数据库，最可能的原因是名字重复
	public AlgInstance getMyAlgInstance();
	public List<Creator> getAvailableCreator() throws ClassNotFoundException, InstantiationException, IllegalAccessException;	
	public List<Function> getAvailableFunctions() throws ClassNotFoundException, InstantiationException, IllegalAccessException;	
	public List<Selector> getAvailableSelector() throws ClassNotFoundException, InstantiationException, IllegalAccessException;	
	public List<Calculator> getAvailableCalculator() throws ClassNotFoundException, InstantiationException, IllegalAccessException;	
	public List<Modifying> getAvailableModifyings() throws ClassNotFoundException, InstantiationException, IllegalAccessException;
	public void run();
	
	/**
	 * 为了画拟合曲线图添加的参数
	 * @return
	 */
	public Calculator getCalculator();
	public GepAlgorithm getMyGepAlgorithm();
	
}
domain\iservice\IgepInputService.java
package domain.iservice;
import java.io.File;
import java.io.IOException;
import jxl.read.biff.BiffException;
import domain.core.inputmodel.DataTable;
public interface IgepInputService {
	public void uploadFile (DataTable set,File file) throws IOException, BiffException;
}
domain\iservice\IgepOutputService.java
package domain.iservice;
import java.io.File;
import java.io.IOException;
import javax.swing.ImageIcon;
import jxl.write.WriteException;
import domain.core.algmodel.configuration.Individual;
import domain.core.outputmodel.AlgInstance;
import domain.service.alg.configuration.Calculator;
public interface IgepOutputService {
	/**
	 * 不用实现
	 */
	public void setImplement(File path);
	
	public void setGeneration(long generation);
	public void setGeneration(long start,long end);
	public void writeExcel (AlgInstance set,File path) throws IOException, WriteException;
	public ImageIcon drawImage(AlgInstance outPut);
	public ImageIcon drawImage(Calculator calculator,Individual individual);
}
domain\service\alg\configuration\Calculator.java
package domain.service.alg.configuration;
import java.util.List;
import domain.core.algmodel.configuration.GepAlgorithm;
import domain.core.algmodel.configuration.Individual;
import domain.core.inputmodel.DataTable;
import exception.IllegalInputSet;
/**
 * 抽象类，所有的适应值计算方法均需继承此类，请确保继承此类的所有子类具有一个无参数的构造函数，否则会出现异常
 * @author 申远
 */
public abstract class Calculator {
	private float selectionRage;
	private float accuray;
	private final String name;
	private DataTable inputSet;
	/**
	 * 
	 * @param name 计算适应值类的的名字，这个名字会自动在界面上显示
	 */
	public Calculator(String name){
		this.name=name;
	}
	/**
	 * 返回选择范围
	 * @return 选择范围
	 */
	public float getSelectionRange(){
		return selectionRage;
	}
	/**
	 * 设置选择范围，选择范围是把函数值转化为适应值的时候所用到的重要参数，请确保选择范围大于0
	 * @param selectionRange 选择范围
	 */
	public void setSelectionRange(float selectionRange){
		this.selectionRage=selectionRange;
	}
	/**
	 * 返回求解精度，如0.01表示如果误差小于0.01，则忽略此误差
	 * @return 求解精度
	 */
	public float getAccuray(){
		return accuray;
	}
	/**
	 * 设置求解精度
	 * @param accuray 求解精度
	 */
	public void setAccuray(float accuray){
		this.accuray=accuray;
	}
	/**
	 * 返回输入集
	 * @return 输入集
	 */
	public DataTable getInputSet() {
		return inputSet;
	}
	/**
	 * 设置输入集
	 * @param inputSet 待设置的输入集
	 */
	public void setInputSet(DataTable inputSet) {
		this.inputSet = inputSet;
	}
	/**
	 * 计算适应值，只需要计算种群队列队尾种群中所有的适应值即可。
	 */
	public abstract void calculateFitness(GepAlgorithm gepAlgorithm);
	/**
	 * 用给定的个体计算给定的输入集的解，修改输入集通过调用setInputSet来完成
	 * @param individual 用于求解输入集的个体
	 * @return 保存有问题解的List
	 * @throws IllegalInputSet 输入集存在问题将会抛出此异常
	 */
	public abstract List<Float> calculateInputSet(Individual individual) throws IllegalInputSet;
	/**
	 * 返回求解方式的名称
	 * @return 求解名称的字符串表示。
	 */
	@Override
	public final String toString() {
		// TODO Auto-generated method stub
		return name;
	}
}
domain\service\alg\configuration\Creator.java
package domain.service.alg.configuration;
import java.util.List;
import domain.core.algmodel.configuration.GepAlgorithm;
import domain.core.algmodel.genecomponent.Function;
import domain.core.algmodel.genecomponent.Variable;
/**
 * 请确保子类有默认构造函数，否则会出现错误
 */
public abstract class Creator {
	private final String name;
	private List<Function> selectedFunctions;
	private List<Variable> variables;
	private float start;
	private float end;
	private int constanListSize;
	public Creator(String name){
		this.name=name;
	}
	@Override
	public final String toString() {
		// TODO Auto-generated method stub
		return name;
	}
	public void setSelectedFunctions(List<Function> functions){
		selectedFunctions=functions;
	}
	
	
	public void setVariables(List<Variable> variables){
		this.variables=variables; 
	}
	public List<Variable> getVariables() {
		return variables;
	}
	
	
	public List<Function> getSelectedFunctions() {
		return selectedFunctions;
	}
	
	public void setRandomConstantRange(float start,float end){
		this.start=start;
		this.end=end;
	}
	public float getStart() {
		return start;
	}
	public float getEnd() {
		return end;
	}
	public int getConstanListSize() {
		return constanListSize;
	}
	public void setConstanListSize(int constanListSize) {
		this.constanListSize = constanListSize;
	}
	public abstract void create(GepAlgorithm algorithm);
}
domain\service\alg\configuration\GepAlgService.java
package domain.service.alg.configuration;
import java.io.File;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import jxl.read.biff.BiffException;
import data.dao.HibernateDataContext;
import data.dao.IHibernateDataContext;
import domain.core.algmodel.configuration.GepAlgorithm;
import domain.core.algmodel.configuration.Individual;
import domain.core.algmodel.configuration.Population;
import domain.core.algmodel.genecomponent.Function;
import domain.core.inputmodel.DataTable;
import domain.core.outputmodel.AlgInstance;
import domain.core.outputmodel.GepConfiguration;
import domain.core.outputmodel.OutputIndividual;
import domain.core.outputmodel.OutputPopulation;
import domain.iservice.IgepAlgService;
import domain.service.input.DefaultGepInput;
import domain.service.input.IgepInput;
import exception.Duplicated;
/**
 * 这个参数配置一个方法就可以完成了，非常简洁了
 */
public class GepAlgService implements IgepAlgService {
	private Calculator myCalculator;
	private Selector mySelector;
	private Creator myCreator;
	private Modifying myModifying;
	private GepAlgorithm myGepAlgorithm=new GepAlgorithm();
	private GepConfiguration myConfiguration;
	private IgepInput igepInput=new DefaultGepInput();
	private AlgInstance myAlgInstance = new AlgInstance();
	
	
	
	/**
	 * 为了画拟合曲线图添加的参数
	 * @return
	 */
	public Calculator getCalculator(){
		return myCalculator;
	}
	
	@Override
	public void saveArgumentsToDb(GepConfiguration myConfiguration) throws Duplicated {
		// TODO Auto-generated method stub
		try {
			IHibernateDataContext dbAccess=new HibernateDataContext();
			dbAccess.save(myConfiguration);
			
		} catch (Exception e) {
			// TODO Auto-generated catch block
			Duplicated newDuplicated=new Duplicated();
			newDuplicated.initCause(e);
			throw newDuplicated;
		}
	}
	@Override
	public List<GepConfiguration> readArgumentsFromDb() {
		// TODO Auto-generated method stub
		IHibernateDataContext dbAccess=new HibernateDataContext();
		return dbAccess.findAll(GepConfiguration.class);
	}
	@Override
	public void setParameters(GepConfiguration myConfiguration) throws InstantiationException, IllegalAccessException, ClassNotFoundException, BiffException, IOException {
		// TODO Auto-generated method stub
		this.myConfiguration=myConfiguration;
		myCreator=(Creator) Class.forName(myConfiguration.getCreator()).newInstance();
		myCreator.setSelectedFunctions(getFunctionList(myConfiguration.getFunctionList().split(",")));
		
		myCalculator=(Calculator) Class.forName(myConfiguration.getCalculator()).newInstance();
		myCalculator.setAccuray(Float.parseFloat(myConfiguration.getAccuray()));
		myCalculator.setSelectionRange(Float.parseFloat(myConfiguration.getSelectionRange()));
		mySelector=(Selector) Class.forName(myConfiguration.getSelector()).newInstance();
		myModifying=(Modifying) Class.forName(myConfiguration.getModify()).newInstance();
		
		
		myModifying.setGeneRecombineRate(Float.parseFloat(myConfiguration.getGeneRecombineRate()));
		myModifying.setGeneTransportRate(Float.parseFloat(myConfiguration.getGeneTransportRate()));
		myModifying.setIsElements(stringArrayToIntegerList(myConfiguration.getIsElement().split(",")));
		myModifying.setIsTransportRate(Float.parseFloat(myConfiguration.getIsTransportRate()));
		myModifying.setMutateRate(Float.parseFloat(myConfiguration.getMutateRate()));
		myModifying.setOnePointRecombineRate(Float.parseFloat(myConfiguration.getOnePointRecombineRate()));
		myModifying.setRisElements(stringArrayToIntegerList(myConfiguration.getRisElement().split(",")));
		myModifying.setRisTransportRate(Float.parseFloat(myConfiguration.getRisTransportRate()));
		myModifying.setTwoPointRecombineRate(Float.parseFloat(myConfiguration.getTwoPointRecombineRate()));
		
		myGepAlgorithm.setFunctionList(getFunctionList(myConfiguration.getFunctionList().split(",")));
		myGepAlgorithm.setMaxGeneration(Long.parseLong(myConfiguration.getMaxGeneration()));
		myGepAlgorithm.setNormalGeneNumber(Integer.parseInt(myConfiguration.getNormalGeneNumber()));
		myGepAlgorithm.setHomeoticGeneNumber(Integer.parseInt(myConfiguration.getHomeoticGeneNumber()));
		myGepAlgorithm.setNormalHeaderLength(Integer.parseInt(myConfiguration.getNormalHeaderLength()));
		myGepAlgorithm.setHomeoticHeaderLength(Integer.parseInt(myConfiguration.getHomeoticHeaderLength()));
		myGepAlgorithm.setPopulationSize(Integer.parseInt(myConfiguration.getPopulationSize()));
		int maxArity=getMaxFunctionArity(myCreator.getSelectedFunctions());
		int normalTailLength=myGepAlgorithm.getNormalHeaderLength()*(maxArity-1)+1;
		int homeoticTailLength=myGepAlgorithm.getHomeoticHeaderLength()*(maxArity-1)+1;
		myGepAlgorithm.setNormalTailLength(normalTailLength);
		myGepAlgorithm.setHomeoticTailLength(homeoticTailLength);
		myGepAlgorithm.setIndividualLength(myGepAlgorithm.getHomeoticGeneLength()*myGepAlgorithm.getHomeoticGeneNumber()+myGepAlgorithm.getNormalGeneLength()*myGepAlgorithm.getNormalGeneNumber());
		
		igepInput.setFile(new File(myConfiguration.getInputFile()));
		DataTable is=new DataTable();
		igepInput.read(is);
		setInputSet(is);
	}
	@Override
	public List<Function> getAvailableFunctions() throws ClassNotFoundException, InstantiationException, IllegalAccessException {
		// TODO Auto-generated method stub
		String binaryPath="domain.service.alg.userdefined.function";
		return getClassBinaryName(binaryPath, Function.class);
	}
	@Override
	public List<Selector> getAvailableSelector() throws ClassNotFoundException, InstantiationException, IllegalAccessException {
		// TODO Auto-generated method stub
		String binaryPath="domain.service.alg.userdefined.selector";
		return getClassBinaryName(binaryPath, Selector.class);
	}
	@Override
	public List<Calculator> getAvailableCalculator() throws ClassNotFoundException, InstantiationException, IllegalAccessException {
		// TODO Auto-generated method stub
		String binaryPath="domain.service.alg.userdefined.calculator";
		return getClassBinaryName(binaryPath, Calculator.class);
	}
	@Override
	public List<Creator> getAvailableCreator() throws ClassNotFoundException, InstantiationException, IllegalAccessException {
		// TODO Auto-generated method stub
		String binaryPath="domain.service.alg.userdefined.creator";
		return getClassBinaryName(binaryPath, Creator.class);
	}
	@Override
	public List<Modifying> getAvailableModifyings() throws ClassNotFoundException, InstantiationException, IllegalAccessException {
		// TODO Auto-generated method stub
		String binaryPath="domain.service.alg.userdefined.modify";
		return getClassBinaryName(binaryPath, Modifying.class);
	}
	
	/**请运行完所有set方法后再运行此方法。
	 * 在UI层要保证如下要求
	 * 若用户执行了setParameters方法，然后在这个类外部修改了为set方法传进来的GepConfiguration，请让用户为配置文件重新命名，否则可能无法正确保存信息到数据库，乃至抛出异常，切记。
	 * (non-Javadoc)
	 * @see domain.iservice.IgepAlgService#run()
	 */
	@Override
	public void run() {
		// TODO Auto-generated method stub
		Set<OutputPopulation> outputPopulations=new LinkedHashSet<OutputPopulation>();
		myAlgInstance.setPopulationSet(outputPopulations);
		myCreator.create(myGepAlgorithm);
		for(int i=0;i<myGepAlgorithm.getMaxGeneration();i++){
			myCalculator.calculateFitness(myGepAlgorithm);
			outputPopulations.add(generateOutputPopulation(myGepAlgorithm.getPopulationQueue().getLast()));
				
			System.out.println("-----------------------------\n代数："+i);
//			System.out.println("选择之前");
			System.out.println("最大适应值: "+myGepAlgorithm.getPopulationQueue().getLast().getBestIndividual().getFitness());
			for(Individual individual:myGepAlgorithm.getPopulationQueue().getLast().getIndividuals())
				System.out.println(individual.getFitness());
			Population newPopulation=null;
			
			newPopulation = mySelector.select(copyPopulations(myGepAlgorithm.getPopulationQueue()));
			myGepAlgorithm.addPopulation(newPopulation);
			
			/*
			System.out.println("*******************\n选择之后");
			System.out.println("最大适应值: "+myGepAlgorithm.getPopulationQueue().getLast().getBestIndividual().getFitness());
			for(Individual individual:myGepAlgorithm.getPopulationQueue().getLast().getIndividuals())
				System.out.println(individual.getFitness());
			*/
			float maxFitness=myGepAlgorithm.getPopulationQueue().getLast().getBestIndividual().getFitness();
			if(Math.abs(maxFitness-myGepAlgorithm.getMaxFitness())<myCalculator.getAccuray())
				return;
				/*
				System.out.println(i+"\n-----------------------------");
				for(Individual individual:newPopulation.getIndividuals())
					System.out.println(individual.getFitness()+"\n"+individual);
				*/
			newPopulation.setGeneration(i+1);
			myModifying.run(myGepAlgorithm);
			
		}
		
		//myAlgInstance = generateAlgInstance(myGepAlgorithm);
//		myAlgInstance.setPopulationSet(outputPopulations);
		
		
		//generateAlgInstance(myGepAlgorithm);
		/*Iterator<OutputPopulation> ouIterator=outputPopulations.iterator();
		OutputPopulation out;
		System.out.println("begin");
		while(ouIterator.hasNext()){
			out=ouIterator.next();
			System.out.println(out.getBestOutputIndividual().getFitness());
		}
		System.out.println("end");
		System.out.println("hahahaha~");*/
		
		writeDataToDB(outputPopulations);
	}
	
	
	
	
	
	@Override
	public AlgInstance getMyAlgInstance(){
		return myAlgInstance;
	}
	
	
	
	
	
	
	private void setInputSet(DataTable inputSet) {
		myCreator.setVariables(inputSet.getColumns().getVariableList().subList(0, inputSet.getColumns().size()-1));
		myCalculator.setInputSet(inputSet);
		myGepAlgorithm.setMaxFitness(myCalculator.getSelectionRange()*myCalculator.getInputSet().getRows().size());
		myGepAlgorithm.setVariableList(inputSet.getColumns().getVariableList().subList(0, inputSet.getColumns().size()-1));
	}
	
	private <T> List<T> getClassBinaryName(String binaryPath,Class<T> typeClass) throws ClassNotFoundException, InstantiationException, IllegalAccessException{
		String filePathString=".\\bin\\"+binaryPath.replace(".", "\\");
		File classfiles=new File(filePathString);
		List<T> resultList=new ArrayList<T>(classfiles.list().length);
		for(String string:classfiles.list()){
			if(!string.contains("$")){
				Class<?> myClass=Class.forName(binaryPath+"."+string.subSequence(0, string.length()-6));
				T newInstance=typeClass.cast(myClass.newInstance());
				resultList.add(newInstance);				
			}
		}
		return resultList;
	}
	private int getMaxFunctionArity(List<Function> functionlist){
		int max=0;
		for(Function function:functionlist)
			if(function.getArity()>max)
				max=function.getArity();
		return max;
	}
	
	private List<Function> getFunctionList(String [] classNames) throws InstantiationException, IllegalAccessException, ClassNotFoundException{
		List<Function> result=new ArrayList<Function>();
		for(int i=0;i<classNames.length;i++)
			result.add((Function) Class.forName(classNames[i]).newInstance());
		return result;
	}
	private List<Integer> stringArrayToIntegerList(String[] array){
		List<Integer> result=new ArrayList<Integer>(array.length);
		for(int i=0;i<array.length;i++)
			result.add(Integer.parseInt(array[i]));
		return result;
	}
	private void writeDataToDB(Set<OutputPopulation> outputPopulations){
		IHibernateDataContext dbAccess=new HibernateDataContext();
		myAlgInstance=generateAlgInstance(myGepAlgorithm);
		myAlgInstance.setPopulationSet(outputPopulations);
		List<GepConfiguration> list=readArgumentsFromDb();
		int i=0;
		for(;i<list.size();i++)
			if(list.get(i).getName().equals(myAlgInstance.getGepConfiguration().getName())){
				myAlgInstance.setGepConfiguration(list.get(i));
				break;
			}
		if(i==list.size()){
			try {
				saveArgumentsToDb(myConfiguration);
			} catch (Duplicated e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			myAlgInstance.setGepConfiguration(myConfiguration);
		}
		dbAccess.save(myAlgInstance);
	}
	private AlgInstance generateAlgInstance(GepAlgorithm algorithm){
		AlgInstance result=new AlgInstance();
		result.setGepConfiguration(myConfiguration);
		result.setRunTimes((long) 1);
		result.setTotalGeneration(algorithm.getPopulationQueue().getLast().getGeneration());
		return result;
	}
	public OutputPopulation generateOutputPopulation(Population population) {
		// TODO Auto-generated method stub
		OutputPopulation result=new OutputPopulation();
		result.setGeneration(population.getGeneration());
		Set<OutputIndividual> individuals=new LinkedHashSet<OutputIndividual>();
		for(Individual individual:population.getIndividuals())
			individuals.add(generateOutputIndividual(individual));
		result.setIndvididualSet(individuals);
		return result;
	}
	private OutputIndividual generateOutputIndividual(Individual individual){
		OutputIndividual result=new OutputIndividual();
		result.setExpression(individual.toString());
		result.setFitness(individual.getFitness());
		return result;
	}
	//未完成
	private Deque<Population> copyPopulations(Deque<Population> populations){
		Deque<Population> result=new ArrayDeque<Population>(2);
		result.add(populations.getFirst().copy());
		result.add(populations.getLast().copy());
		return result;
	}
	@Override
	public GepAlgorithm getMyGepAlgorithm() {
		return myGepAlgorithm;
	}
}
domain\service\alg\configuration\Modifying.java
package domain.service.alg.configuration;
import java.util.LinkedList;
import java.util.List;
import domain.core.algmodel.configuration.GepAlgorithm;
/**
 * 请确保子类有默认构造函数，否则会出现错误
 */
public abstract class Modifying {
	private final String name;
	private float mutateRate;
	private float isTransportRate;
	private List<Integer> isElements=new LinkedList<Integer>();
	private float risTransportRate;
	private List<Integer> risElements=new LinkedList<Integer>();
	private float geneTransportRate;
	private float onePointRecombineRate;
	private float twoPointRecombineRate;
	private float geneRecombineRate;
	/**
	 * 遗传算子名称
	 * @param name 遗传算子名称
	 */
	public Modifying(String name){
		this.name=name;
	}
	/**
	 * 返回遗传算子的名称
	 * @see java.lang.Object#toString()
	 */
	@Override
	public final String toString() {
		// TODO Auto-generated method stub
		return name;
	}
	/**
	 * 返回变异概率
	 * @return 变异概率，大于0小于1
	 */
	public float getMutateRate() {
		return mutateRate;
	}
	/**
	 * 设置变异概率
	 * @param variateRate 变异概率
	 */
	public void setMutateRate(float variateRate) {
		this.mutateRate = variateRate;
	}
	/**
	 * 返回IS转座概率
	 * @return IS转座概率
	 */
	public float getIsTransportRate() {
		return isTransportRate;
	}
	/**
	 * 设置IS转座概率
	 * @param isTransportRate IS转座概率，大于0小于1
	 */
	public void setIsTransportRate(float isTransportRate) {
		this.isTransportRate = isTransportRate;
	}
	/**
	 * 返回IS转座的可能长度
	 * @return 由IS转座可能长度组成的List
	 */
	public List<Integer> getIsElements() {
		return isElements;
	}
	/**
	 * 设置IS转座的可能长度
	 * @param isLength IS转座的可能长度的List
	 */
	public void setIsElements(List<Integer> isLength) {
		this.isElements = isLength;
	}
	/**
	 * 返回RIS转座概率
	 * @return 返回RIS转座概率
	 */
	public float getRisTransportRate() {
		return risTransportRate;
	}
	/**
	 * 设置RIS转座概率，大于0小于1
	 * @param risTransportRate RIS转座概率
	 */
	public void setRisTransportRate(float risTransportRate) {
		this.risTransportRate = risTransportRate;
	}
	/**
	 * 返回RIS转座的可能长度
	 * @return RIS转座的长度List
	 */
	public List<Integer> getRisElements() {
		return risElements;
	}
	/**
	 * 设置RIS转座可能长度
	 * @param risLength list里面保存RIS转座可能长度
	 */
	public void setRisElements(List<Integer> risLength) {
		this.risElements = risLength;
	}
	/**
	 * 返回基因转座的概率
	 * @return 基因转座概率
	 */
	public float getGeneTransportRate() {
		return geneTransportRate;
	}
	/**
	 * 设置基因转座概率，大于0小于1
	 * @param geneTransportRate 基因转座概率
	 */
	public void setGeneTransportRate(float geneTransportRate) {
		this.geneTransportRate = geneTransportRate;
	}
	/**
	 * 返回单点重组概率
	 * @return 单点重组概率
	 */
	public float getOnePointRecombineRate() {
		return onePointRecombineRate;
	}
	/**
	 * 设置单点重组概率
	 * @param onePointRecombineRate 单点重组概率，大于0小于1
	 */
	public void setOnePointRecombineRate(float onePointRecombineRate) {
		this.onePointRecombineRate = onePointRecombineRate;
	}
	/**
	 * 返回两点重组概率
	 * @return 两点重组概率
	 */
	public float getTwoPointRecombineRate() {
		return twoPointRecombineRate;
	}
	/**
	 * 设置两点重组概率
	 * @param twoPointRecombineRate 两点重组概率,大于0小于1
	 */
	public void setTwoPointRecombineRate(float twoPointRecombineRate) {
		this.twoPointRecombineRate = twoPointRecombineRate;
	}
	/**
	 * 返回基因重组概率
	 * @return 基因重组概率
	 */
	public float getGeneRecombineRate() {
		return geneRecombineRate;
	}
	/**
	 * 设置基因重组概率，大于0小于1
	 * @param geneRecombineRate 基因重组概率
	 */
	public void setGeneRecombineRate(float geneRecombineRate) {
		this.geneRecombineRate = geneRecombineRate;
	}
	/**
	 * 整个算法的入口，只需要操作种群队列中的队尾即可。
	 * @param myGepAlgorithm 算法集，保存有种群和各种参数
	 */
	public abstract void run(GepAlgorithm myGepAlgorithm);
	/**
	 * 对操作种群队列中队尾的种群进行变异
	 * @param myGepAlgorithm 算法集，保存有种群和各种参数
	 */
	public abstract void mutate(GepAlgorithm myGepAlgorithm);
	/**
	 * 对操作种群队列中队尾的种群进行IS转座
	 * @param myGepAlgorithm 算法集，保存有种群和各种参数
	 */
	public abstract void isTransport(GepAlgorithm myGepAlgorithm);
	/**
	 * 对操作种群队列中队尾的种群进行RIS转座
	 * @param myGepAlgorithm 算法集，保存有种群和各种参数
	 */
	public abstract void risTransport(GepAlgorithm myGepAlgorithm);
	/**
	 * 对操作种群队列中队尾的种群进行基因转座
	 * @param myGepAlgorithm 算法集，保存有种群和各种参数
	 */
	public abstract void geneTransport(GepAlgorithm myGepAlgorithm);
	/**
	 * 对操作种群队列中队尾的种群进行单点重组
	 * @param myGepAlgorithm 算法集，保存有种群和各种参数
	 */
	public abstract void onePointRecombine(GepAlgorithm myGepAlgorithm);
	/**
	 * 对操作种群队列中队尾的种群进行两点重组
	 * @param myGepAlgorithm 算法集，保存有种群和各种参数
	 */
	public abstract void twoPointRecombine(GepAlgorithm myGepAlgorithm);
	/**
	 * 对操作种群队列中队尾的种群进行基因重组
	 * @param myGepAlgorithm 算法集，保存有种群和各种参数
	 */
	public abstract void geneRecombine(GepAlgorithm myGepAlgorithm);
}
domain\service\alg\configuration\Selector.java
package domain.service.alg.configuration;
import java.util.Deque;
import domain.core.algmodel.configuration.Population;
/**
 * 请确保子类有默认构造函数，否则会出现错误
 */
public abstract class Selector {
	private final String name;
	public Selector(String name){
		this.name=name;
	}
	@Override
	public final String toString() {
		// TODO Auto-generated method stub
		return name;
	}
	/**
	 * 不需要负责更新种群代数，插入新个体就可以
	 * @return TODO
	 */
	public abstract Population select(Deque<Population> population);
}
domain\service\alg\userdefined\calculator\AbsoluteCalculator.java
package domain.service.alg.userdefined.calculator;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import domain.core.algmodel.configuration.GepAlgorithm;
import domain.core.algmodel.configuration.Individual;
import domain.core.algmodel.genecomponent.Constant;
import domain.core.algmodel.genecomponent.Function;
import domain.core.algmodel.genecomponent.GenePiece;
import domain.core.algmodel.genecomponent.Variable;
import domain.core.algmodel.individualcomponent.Gene;
import domain.core.algmodel.individualcomponent.HomeoticGene;
import domain.core.algmodel.individualcomponent.NormalGene;
import domain.core.inputmodel.DataRow;
import domain.core.inputmodel.DataRowCollection;
import domain.service.alg.configuration.Calculator;
import exception.IllegalInputSet;
public class AbsoluteCalculator extends Calculator{
	private GepAlgorithm gepAlgorithm;
	public AbsoluteCalculator(){
		super("绝对计算方式");
	}
	@Override
	public void calculateFitness(GepAlgorithm gepAlgorithm) {
		this.gepAlgorithm=gepAlgorithm;
		List<Individual> individuals=gepAlgorithm.getPopulationQueue().getLast().getIndividuals();
		DataRowCollection rows= getInputSet().getRows();
		List<Float> individualValueInMulHomeGene;
		List<Float> oneRowFitnessInMulHomeGene;
		List<Float> sumFitness=new ArrayList<Float>(gepAlgorithm.getHomeoticGeneNumber());
		float userFunctionValue;
		int homeoticGeneIndex;
		for(Individual individual:individuals){
			for(int i=0;i<gepAlgorithm.getHomeoticGeneNumber();i++)
				sumFitness.add((float) 0);
			
			for(int i=0;i<rows.size();i++){
				
				individualValueInMulHomeGene=calculateIndividualValueWithMulHomeGene(individual,rows.get(i));
				userFunctionValue=(Float)rows.get(i).getValue(rows.get(i).getColumns().size()-1);
				oneRowFitnessInMulHomeGene=calculateOneRowFitnessWithMulHomeoGene(individualValueInMulHomeGene,userFunctionValue);
				addToFitnessSum(oneRowFitnessInMulHomeGene, sumFitness);
				clearFunctionFlag(individual);
			}
			
			homeoticGeneIndex=selectIndividualFitness(sumFitness);
			if(homeoticGeneIndex==-1){
				individual.setFitness((float) 0);
				individual.setSelectedHomeoticGeneNumber(-1);
			}
			else {
				individual.setFitness(sumFitness.get(homeoticGeneIndex));
				individual.setSelectedHomeoticGeneNumber(homeoticGeneIndex);				
			}
			sumFitness.clear();
		}
	}
	@Override
	public List<Float>  calculateInputSet(Individual individual) throws IllegalInputSet{
		DataRowCollection rows= getInputSet().getRows();
		List<Float> result = new ArrayList<Float>(getInputSet().getRows().size());
		float value;
		for(int i=0;i<rows.size();i++){
			try {
				value=calculateIndividualValueWithMulHomeGene(individual, rows.get(i)).get(individual.getSelectedHomeoticGeneNumber());
				result.add(value);
				clearFunctionFlag(individual);
			} catch (ArithmeticException e) {
				IllegalInputSet illegalInputSet=new IllegalInputSet();
				illegalInputSet.initCause(e);
				throw illegalInputSet;
			}
		}
		return result;
	}
	
	
	
	private List<Float> calculateIndividualValueWithMulHomeGene(Individual individual,DataRow row){
		for(NormalGene gene:individual.getNormalGeneList()){
			assignValueToVariable(gene, row);
			calculateGeneValue(gene, individual);
		}
		List<Float> resulList=new ArrayList<Float>(gepAlgorithm.getHomeoticGeneNumber());
		float result;
		for(HomeoticGene homeoticGene:individual.getHomeoticGeneList()){
			result=calculateGeneValue(homeoticGene, individual);
			resulList.add(result);
		}
		return resulList;
	}
	
	
	private List<Float> calculateOneRowFitnessWithMulHomeoGene(List<Float> fList,float target){
		List<Float> result=new ArrayList<Float>(fList.size());
		float minus;
		float abs;
		for(float expected:fList){
			minus=expected-target;
			abs=Math.abs(minus);
			if(abs<getAccuray())
				abs=0;
			result.add(getSelectionRange()-abs);
		}
		return result;
	}
	private void addToFitnessSum(List<Float>  row,List<Float> sum){
		for(int i=0;i<row.size();i++)
			sum.set(i, row.get(i)+sum.get(i));
			
	}
	private int selectIndividualFitness(List<Float> sumFitness){
		int index=-1;
		float max=0;
		float itemFitness;
		for(int i=0;i<sumFitness.size();i++){
			itemFitness=sumFitness.get(i);
			if(Float.isInfinite(itemFitness)||Float.isNaN(itemFitness)||itemFitness<=0)
				continue;
			else if(max<sumFitness.get(i)){
				index=i;
				max=itemFitness;
			}
		}
		return index;
	}
	private void assignValueToVariable(NormalGene gene,DataRow row){
		for(GenePiece genePiece:gene.getContainedGenePieces()){
			if(genePiece.getClass().equals(Variable.class)){
				Variable variable=(Variable) genePiece;
				for(int i=0;i<row.getColumns().size();i++){
					
					if (row.getColumns().get(i).getColumnName().equals(variable.getName())) {
						variable.setValue((Float)row.getValue(i));
						break;
					}
					
				}
				
			}
		}
	}
	private float calculateGeneValue(Gene gene,Individual individual){
		int length=calcEfficientLength(gene);
		int lastNonTerminate;
		int arity;
		while(length>1){
			lastNonTerminate=findLastNonTerminate(gene, length);
			Function function=(Function)gene.getContainedGenePieces().get(lastNonTerminate);
			arity=function.getArity();
			execMathFunction(gene, individual,function,length,arity);
			length-=arity;
		}
		float value=((GenePiece)gene.getContainedGenePieces().get(0)).getValue();
		gene.setValue(value);
		return value;
	}
	private int calcEfficientLength(Gene gene){
		int length=1;
		int arity;
		GenePiece genePiece;
		for(int i=0;i<length;i++){
			genePiece=gene.getContainedGenePieces().get(i);
			if(Function.class.isInstance(genePiece)){
				if(Float.isNaN(((Function)genePiece).getValue())){
					arity=((Function)genePiece).getArity();
					length+=arity;					
				}
			}
		}
		return length;
	}
	private int findLastNonTerminate(Gene gene,int efficientLength){
		GenePiece genePiece;
		int result=0;
		for(int i=efficientLength-1;i>=0;i--){
			genePiece=gene.getContainedGenePieces().get(i);
			if(Function.class.isInstance(genePiece)){
				if(Float.isNaN(((Function)genePiece).getValue())){
					result=i;
					break;
				}
			}
		}
		return result;
	}
	private void execMathFunction(Gene gene,Individual individual,Function function,int efficientLength,int arity){
		Deque<GenePiece> genePieces=new ArrayDeque<GenePiece>(arity);
		Deque<Float> valueDeque=new ArrayDeque<Float>(arity);
		for(int i=0;i<arity;i++)
			genePieces.addFirst(gene.getContainedGenePieces().get(efficientLength-i-1));		
		if(gene.getClass().equals(HomeoticGene.class)){
			int index;
			while(!genePieces.isEmpty()){
				GenePiece valueSource=(GenePiece)genePieces.removeLast();
				if(Function.class.isInstance(valueSource)){
					valueDeque.addFirst(valueSource.getValue());
				}
				else {
					index=Math.round(((Constant)valueSource).getValue());
					valueDeque.addFirst(individual.getNormalGeneList().get(index).getValue());
				}
			}			
		}
		else {
			while(!genePieces.isEmpty()){
				float value=((GenePiece)genePieces.removeLast()).getValue();
				valueDeque.addFirst(value);
			}
		}
		float value=function.operate(valueDeque);
		function.setValue(value);
	}
	private void clearFunctionFlag(Individual individual){
		for(NormalGene normalGene:individual.getNormalGeneList()){
			for(GenePiece genePiece:normalGene.getContainedGenePieces())
				if(Function.class.isInstance(genePiece))
					((Function)genePiece).setValue(Float.NaN);
		}
		for(HomeoticGene homeoticGene:individual.getHomeoticGeneList()){
			for(GenePiece genePiece:homeoticGene.getContainedGenePieces())
				if(Function.class.isInstance(genePiece))
					((Function)genePiece).setValue(Float.NaN);
		}
	}
}
domain\service\alg\userdefined\creator\DefaultCreator.java
package domain.service.alg.userdefined.creator;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import common.ObjectCopy;
import domain.core.algmodel.configuration.GepAlgorithm;
import domain.core.algmodel.configuration.Individual;
import domain.core.algmodel.configuration.Population;
import domain.core.algmodel.genecomponent.Constant;
import domain.core.algmodel.genecomponent.Function;
import domain.core.algmodel.genecomponent.GenePiece;
import domain.core.algmodel.genecomponent.Variable;
import domain.service.alg.configuration.Creator;
public class DefaultCreator extends Creator{
	private GepAlgorithm algorithm;
	private int funcNumber;
	private int variableNumber;
	private int funcntionVariablNum;
	private int functionConstantNum;
	public DefaultCreator() {
		super("随机生成种群");
		// TODO Auto-generated constructor stub
	}
	@Override
	public void create(GepAlgorithm algorithm){
		// TODO Auto-generated method stub
		
		this.algorithm=algorithm;
		Population firstPopulation=new Population(algorithm.getPopulationSize());
		Individual insertingIndividual;
		List<GenePiece> containedGenePieces;
		
		funcNumber=getSelectedFunctions().size();
		variableNumber=getVariables().size();
		funcntionVariablNum=funcNumber+variableNumber;
		functionConstantNum=funcNumber+1;
		
		for(int i=0;i<algorithm.getPopulationSize();i++){
			insertingIndividual=new Individual();
			containedGenePieces=new ArrayList<GenePiece>(algorithm.getIndividualLength());
			for(int j=0;j<algorithm.getNormalGeneNumber();j++){
				fillNormalGeneHeader(containedGenePieces);
				fillNormalGeneTail(containedGenePieces);
			}
			for(int j=0;j<algorithm.getHomeoticGeneNumber();j++){
				fillHomeoticHeader(containedGenePieces);
				fillHomeoticGeneTail(containedGenePieces);
			}
			insertingIndividual.setContainedGenePieces(containedGenePieces, algorithm.getNormalGeneNumber(), algorithm.getNormalHeaderLength(), algorithm.getNormalGeneLength(), algorithm.getHomeoticGeneNumber(), algorithm.getHomeoticHeaderLength(), algorithm.getHomeoticGeneLength());
			firstPopulation.addIndividual(insertingIndividual);
		}
		algorithm.addPopulation(firstPopulation);
	}
	private void fillNormalGeneHeader(List<GenePiece> containedGenePieces){
		Random functionRand=new Random();
		Random variableRand=new Random();
		Random typeRandom=new Random();
		int type;
		for(int i=0;i<algorithm.getNormalHeaderLength();i++){
			type=typeRandom.nextInt(funcntionVariablNum);	
			if(type<funcNumber){
				//插入函数
				Function newFunction=(Function) ObjectCopy.newInstance(getSelectedFunctions().get(functionRand.nextInt(getSelectedFunctions().size())));
				containedGenePieces.add(newFunction);
			}
			else {
				//插入变量
				Variable newVariable=(Variable)ObjectCopy.newInstance(getVariables().get(variableRand.nextInt(getVariables().size())));
				containedGenePieces.add(newVariable);
			}
		}
	}
	private void fillNormalGeneTail(List<GenePiece> containedGenePieces){
		Random variableRand=new Random();
		for(int i=0;i<algorithm.getNormalTailLength();i++){
			//插入变量
			Variable newVariable=(Variable)ObjectCopy.newInstance(getVariables().get(variableRand.nextInt(getVariables().size())));
			containedGenePieces.add(newVariable);
		}
	}
	private void fillHomeoticHeader(List<GenePiece> containedGenePieces){
		Random functionRand=new Random();
		Random typeRandom=new Random();
		int type;
		Constant constant;
		//在头部先插入一个函数
		Function newFunction=(Function)ObjectCopy.newInstance( getSelectedFunctions().get(functionRand.nextInt(getSelectedFunctions().size())));
		containedGenePieces.add(newFunction);
		
		for(int i=1;i<algorithm.getHomeoticHeaderLength();i++){
			type=typeRandom.nextInt(functionConstantNum);
			if(type<funcNumber){
				//插入函数
				newFunction=(Function)ObjectCopy.newInstance(getSelectedFunctions().get(functionRand.nextInt(getSelectedFunctions().size()))) ;
				containedGenePieces.add(newFunction);
			}
			else {
				//插入常量
				constant=new Constant(algorithm.getNormalGeneNumber());
				containedGenePieces.add(constant);
			}
		}
	}
	private void fillHomeoticGeneTail(List<GenePiece> containedGenePieces){
		Constant constant;
		for(int i=0;i<algorithm.getHomeoticTailLength();i++){
			constant=new Constant(algorithm.getNormalGeneNumber());
			containedGenePieces.add(constant);
		}
	}
	
}
domain\service\alg\userdefined\function\Additioin.java
package domain.service.alg.userdefined.function;
import java.util.Deque;
import domain.core.algmodel.genecomponent.Function;
public class Additioin extends Function {
	/**
	 * 
	 */
	private static final long serialVersionUID = 8408096285882718047L;
	public Additioin() {
		super("+", 2,"+");
		// TODO Auto-generated constructor stub
	}
	@Override
	public float operate(Deque<Float> operators) {
		// TODO Auto-generated method stub
		return operators.removeFirst()+operators.removeFirst();
	}
}
domain\service\alg\userdefined\function\Divide.java
package domain.service.alg.userdefined.function;
import java.util.Deque;
import domain.core.algmodel.genecomponent.Function;
public class Divide extends Function {
	/**
	 * 
	 */
	private static final long serialVersionUID = -3356166328450491371L;
	public Divide() {
		super("/", 2,"/");
		// TODO Auto-generated constructor stub
	}
	@Override
	public float operate(Deque<Float> operators) {
		// TODO Auto-generated method stub
		return operators.removeFirst()/operators.removeFirst();
	}
}
domain\service\alg\userdefined\function\Minus.java
package domain.service.alg.userdefined.function;
import java.util.Deque;
import domain.core.algmodel.genecomponent.Function;
public class Minus extends Function {
	/**
	 * 
	 */
	private static final long serialVersionUID = 3358438185571026193L;
	public Minus() {
		super("-", 2,"-");
		// TODO Auto-generated constructor stub
	}
	@Override
	public float operate(Deque<Float> operators) {
		// TODO Auto-generated method stub
		return operators.removeFirst()-operators.removeFirst();
	}
}
domain\service\alg\userdefined\function\Multiply.java
package domain.service.alg.userdefined.function;
import java.util.Deque;
import domain.core.algmodel.genecomponent.Function;
public class Multiply extends Function{
	/**
	 * 
	 */
	private static final long serialVersionUID = 6877986033210887194L;
	public Multiply() {
		super("*",2,"*");
		// TODO Auto-generated constructor stub
	}
	@Override
	public float operate(Deque<Float> operators) {
		// TODO Auto-generated method stub
		return operators.removeFirst()*operators.removeFirst();
	}
}
domain\service\alg\userdefined\modify\DefaultModifying.java
package domain.service.alg.userdefined.modify;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import common.ObjectCopy;
import domain.core.algmodel.configuration.GepAlgorithm;
import domain.core.algmodel.configuration.Individual;
import domain.core.algmodel.configuration.Population;
import domain.core.algmodel.genecomponent.Constant;
import domain.core.algmodel.genecomponent.Function;
import domain.core.algmodel.genecomponent.GenePiece;
import domain.core.algmodel.individualcomponent.Gene;
import domain.core.algmodel.individualcomponent.HomeoticGene;
import domain.core.algmodel.individualcomponent.NormalGene;
import domain.service.alg.configuration.Modifying;
/**
 * 遗传算子类，实现变异，is转座，ris转座，基因转座，单点重组，多点重组等功能。
 * @author 申远
 */
public class DefaultModifying extends Modifying {
	enum TransportEnum{
		IS,RIS,GENE;
		float rate;
		List<Integer> transportElement;
		public void setRate(float rate){
			this.rate=rate;
		}
		public float getRate(){
			return rate;
		}
		public void setTransportElement(List<Integer> transportElement){
			this.transportElement=transportElement;
		}
		public List<Integer> getTransportElement(){
			return transportElement;
		}
	}
	enum Recombine{
		OnePoint,TwoPoint,GENE;
		float rate;
		public void setRate(float rate){
			this.rate=rate;
		}
		public float getRate(){
			return rate;
		}
	}
	/**
	 * 默认的构造函数，指定本遗传算子的名称为“默认变异方式”
	 */
	public DefaultModifying() {
		super("默认变异方式");
		// TODO Auto-generated constructor stub
	}
	/**
	 * 执行遗传算子，这是程序的入口
	 */
	@Override
	public void run(GepAlgorithm myGepAlgorithm) {
		// TODO Auto-generated method stub
		mutate(myGepAlgorithm);
		isTransport(myGepAlgorithm);
		risTransport(myGepAlgorithm);
		geneTransport(myGepAlgorithm);
		onePointRecombine(myGepAlgorithm);
		twoPointRecombine(myGepAlgorithm);
		geneRecombine(myGepAlgorithm);
	}
	
	@Override
	public void mutate(GepAlgorithm myGepAlgorithm) {
		// TODO Auto-generated method stub
		Random mutateRandom=new Random();
		Random funcOrVarRandom=new Random();
		Random functionRandom=new Random();
		Random variableRandom=new Random();
		Random funcOrConsRandom=new Random();
		int type;
		Population population=myGepAlgorithm.getPopulationQueue().getLast();
		for(Individual mutatingIndividual:population.getIndividuals()){
			for(NormalGene mutatingNormalGene:mutatingIndividual.getNormalGeneList()){
				for(int i=0;i<mutatingNormalGene.getHeader().getContainedGenePieces().size();i++){
					if(mutateRandom.nextFloat()<getMutateRate()){
						type=funcOrVarRandom.nextInt(myGepAlgorithm.getFunctionList().size()+myGepAlgorithm.getVariableList().size());
						if(type<myGepAlgorithm.getFunctionList().size()){
							mutatingNormalGene.getHeader().getContainedGenePieces().set(i, 
									ObjectCopy.newInstance(myGepAlgorithm.getFunctionList().get(functionRandom.nextInt(myGepAlgorithm.getFunctionList().size()))));
						}
						else {
							mutatingNormalGene.getHeader().getContainedGenePieces().set(i, 
							ObjectCopy.newInstance(myGepAlgorithm.getVariableList().get(variableRandom.nextInt(myGepAlgorithm.getVariableList().size()))));
						}
					}
				}
				for(int i=0;i<mutatingNormalGene.getTail().getContainedGenePieces().size();i++){
					if(mutateRandom.nextFloat()<getMutateRate()){
						mutatingNormalGene.getTail().getContainedGenePieces().set(i, 
						ObjectCopy.newInstance(myGepAlgorithm.getVariableList().get(variableRandom.nextInt(myGepAlgorithm.getVariableList().size()))));
					}
				}
			}
			for(HomeoticGene mutatingHomeoticGene:mutatingIndividual.getHomeoticGeneList()){
				if(mutateRandom.nextFloat()<getMutateRate()){
					mutatingHomeoticGene.getContainedGenePieces().set(0, 
							ObjectCopy.newInstance(myGepAlgorithm.getFunctionList().get(functionRandom.nextInt(myGepAlgorithm.getFunctionList().size()))));
				}
				for(int i=1;i<mutatingHomeoticGene.getHeader().getContainedGenePieces().size();i++){
					if(mutateRandom.nextFloat()<getMutateRate()){
						type=funcOrConsRandom.nextInt(myGepAlgorithm.getFunctionList().size()+1);
						if(type<myGepAlgorithm.getFunctionList().size()){
							mutatingHomeoticGene.getHeader().getContainedGenePieces().set(i, 
									ObjectCopy.newInstance(myGepAlgorithm.getFunctionList().get(functionRandom.nextInt(myGepAlgorithm.getFunctionList().size()))));
						}
						else {
							mutatingHomeoticGene.getHeader().getContainedGenePieces().set(i, new Constant(myGepAlgorithm.getNormalGeneNumber()));
						}
					}
				}
				for(int i=0;i<mutatingHomeoticGene.getTail().getContainedGenePieces().size();i++){
					if(mutateRandom.nextFloat()<getMutateRate()){
						mutatingHomeoticGene.getTail().getContainedGenePieces().set(i, new Constant(myGepAlgorithm.getNormalGeneNumber()));
					}
				}
			}
		}
	}
	@Override
	public void isTransport(GepAlgorithm myGepAlgorithm) {
		// TODO Auto-generated method stub
		TransportEnum isTransportEnum=TransportEnum.IS;
		isTransportEnum.setRate(getIsTransportRate());
		isTransportEnum.setTransportElement(getIsElements());
		transportIterateInGene(myGepAlgorithm, isTransportEnum);
	}
	@Override
	public void risTransport(GepAlgorithm myGepAlgorithm) {
		// TODO Auto-generated method stub
		TransportEnum risTransportEnum=TransportEnum.RIS;
		risTransportEnum.setRate(getRisTransportRate());
		risTransportEnum.setTransportElement(getRisElements());
		transportIterateInGene(myGepAlgorithm,risTransportEnum);
	}
	@Override
	public void geneTransport(GepAlgorithm myGepAlgorithm) {
		// TODO Auto-generated method stub
		TransportEnum geneTransportEnum=TransportEnum.GENE;
		geneTransportEnum.setRate(getGeneTransportRate());
		transportIterateInGene(myGepAlgorithm, geneTransportEnum);
	}
	@Override
	public void onePointRecombine(GepAlgorithm myGepAlgorithm) {
		// TODO Auto-generated method stub
		Recombine recombine=Recombine.OnePoint;
		recombine.setRate(getOnePointRecombineRate());
		recombineIterate(myGepAlgorithm, recombine);
	}
	@Override
	public void twoPointRecombine(GepAlgorithm myGepAlgorithm) {
		// TODO Auto-generated method stub
		Recombine recombine=Recombine.TwoPoint;
		recombine.setRate(getTwoPointRecombineRate());
		recombineIterate(myGepAlgorithm, recombine);
	}
	@Override
	public void geneRecombine(GepAlgorithm myGepAlgorithm) {
		// TODO Auto-generated method stub
		Recombine recombine=Recombine.GENE;
		recombine.setRate(getGeneRecombineRate());
		recombineIterate(myGepAlgorithm, recombine);
	}
	private void transportIterateInGene(GepAlgorithm myGepAlgorithm,TransportEnum transportEnum){
		Population population=myGepAlgorithm.getPopulationQueue().getLast();
		Random transportRandom=new Random();
		for(Individual individual:population.getIndividuals()){
			for(NormalGene normalGene:individual.getNormalGeneList()){
				if(transportRandom.nextFloat()<transportEnum.getRate()){
					transportParaDetermination(normalGene, transportEnum, myGepAlgorithm.getNormalHeaderLength(),myGepAlgorithm.getNormalTailLength(),myGepAlgorithm.getNormalGeneNumber(),individual.getNormalGenePieces());
				}
			}
			for(HomeoticGene homeoticGene:individual.getHomeoticGeneList()){
				if(transportRandom.nextFloat()<transportEnum.getRate()){
					transportParaDetermination(homeoticGene, transportEnum ,myGepAlgorithm.getHomeoticHeaderLength(),myGepAlgorithm.getHomeoticTailLength(),myGepAlgorithm.getHomeoticGeneNumber(),individual.getHomeoticGenePieces());
				}
			}
		}
	}
	private void transportParaDetermination(Gene gene,TransportEnum transportEnum,int headerLength,int tailLength,int geneNum,List<GenePiece> genePieces){
		Random sourceLocRandom=new Random();
		Random destLocRandom=new Random();
		Random elementLengthRandom=new Random();
		int elementLength=0;
		int sourceLoc=0;
		int destLoc=0;
		switch (transportEnum) {
		case IS:
			elementLength=transportEnum.transportElement.get(elementLengthRandom.nextInt(transportEnum.transportElement.size()));
			sourceLoc=sourceLocRandom.nextInt(headerLength+tailLength-elementLength);
			destLoc=destLocRandom.nextInt(headerLength-elementLength-1)+1;
			break;
		case RIS:
			elementLength=transportEnum.transportElement.get(elementLengthRandom.nextInt(transportEnum.transportElement.size()));
			sourceLoc=searchFunction(gene, destLocRandom.nextInt(headerLength));
			destLoc=0;
			break;
		case GENE:
			elementLength=headerLength+tailLength;
			sourceLoc=sourceLocRandom.nextInt(geneNum)*(headerLength+tailLength);
			destLoc=destLocRandom.nextInt(geneNum)*(headerLength+tailLength);
			if(sourceLoc<destLoc){
				int temp=sourceLoc;
				sourceLoc=destLoc;
				destLoc=temp;
			}
			else if(sourceLoc==destLoc){
				sourceLoc=-1;
			}
			break;
		}
		if(sourceLoc!=-1){
			if(transportEnum==TransportEnum.GENE){
				transportBegin(genePieces, sourceLoc, destLoc, elementLength, headerLength, transportEnum);
			}
			else {
				transportBegin(gene.getContainedGenePieces(), sourceLoc, destLoc, elementLength, headerLength, transportEnum);
			}
		}
	}
	private int searchFunction(Gene gene,int index){
		int result=-1;
		for(int i=index;i<gene.getContainedGenePieces().size();i++){
			if(gene.getContainedGenePieces().get(i) instanceof Function){
				result=i;
				break;
			}
		}
		return result;
	}
	private void transportBegin(List<GenePiece> genePieces,int source,int dest,int length,int headerLength,TransportEnum transportEnum){
		List<GenePiece> copiedSource=new ArrayList<GenePiece>(length);
		for(int i=0;i<length;i++)
			copiedSource.add(ObjectCopy.newInstance(genePieces.get(i+source)));
		if(transportEnum==TransportEnum.GENE){
			for(int i=0;i<source-dest;i++){
				genePieces.set(source-1-i+length, genePieces.get(source-1-i));
			}
			for(int i=0;i<length;i++){
				genePieces.set(i+dest, copiedSource.get(i));
			}
		}
		else {
			int forLength=headerLength-dest-length;
			for(int i=0;i<forLength;i++){
				genePieces.set(headerLength-i-1, genePieces.get(headerLength-i-1-length));
			}
			for(int i=0;i<length;i++){
				genePieces.set(dest+i, copiedSource.get(i));
			}
		}
	}
	private void recombineIterate(GepAlgorithm gepAlgorithm,Recombine recombine){
		Population population=gepAlgorithm.getPopulationQueue().getLast();
		Random recombineOneRandom=new Random();
		Random recombineOtherRandom=new Random();
		for(int i=0;i<population.getIndividuals().size()-1;i++){
			if(recombineOneRandom.nextFloat()<recombine.getRate()){
				for(int j=i+1;j<population.getIndividuals().size();j++){
					if(recombineOtherRandom.nextFloat()<recombine.getRate()){
						recombineParaDetermination(population.getIndividuals().get(i).getContainedGenePieces(), population.getIndividuals().get(j).getContainedGenePieces(), recombine, gepAlgorithm);
						break;
					}
				}
			}
		}
	}
	private void recombineParaDetermination(List<GenePiece> a,List<GenePiece> b,Recombine recombine,GepAlgorithm gepAlgorithm){
		Random startRandom=new Random();
		Random endRandom=new Random();
		int start=-1;
		int end=-1;
		switch (recombine) {
		case OnePoint:
			end=a.size();
			start=startRandom.nextInt(end);
			break;
		case TwoPoint:
			start=startRandom.nextInt(gepAlgorithm.getHomeoticGeneLength()+gepAlgorithm.getNormalGeneLength());
			end=endRandom.nextInt(gepAlgorithm.getHomeoticGeneLength()+gepAlgorithm.getNormalGeneLength());
			if(start>end){
				int temp=start;
				start=end;
				end=temp;
			}
			break;
		case GENE:
			int geneNo=startRandom.nextInt(gepAlgorithm.getHomeoticGeneNumber()+gepAlgorithm.getNormalGeneNumber());
			if(geneNo<gepAlgorithm.getNormalGeneNumber()){
				start=geneNo*gepAlgorithm.getNormalGeneLength();
				end=start+gepAlgorithm.getNormalGeneLength();
			}
			else {
				start=geneNo*gepAlgorithm.getHomeoticGeneLength();
				end=start+gepAlgorithm.getHomeoticGeneLength();
			}
			break;
		}
		beginRecombine(start, end, a, b);
	}
	private void beginRecombine(int start,int end,List<GenePiece> a,List<GenePiece> b){
		for(int i=start;i<end;i++){
			GenePiece aPiece=a.get(i);
			a.set(i, b.get(i));
			b.set(i, aPiece);
		}
	}
}
domain\service\alg\userdefined\selector\DefaultSelector.java
package domain.service.alg.userdefined.selector;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import java.util.Random;
import common.ObjectCopy;
import domain.core.algmodel.configuration.Individual;
import domain.core.algmodel.configuration.Population;
import domain.service.alg.configuration.Selector;
public class DefaultSelector extends Selector{
	private long maxGeneration;
	public DefaultSelector() {
		// TODO Auto-generated constructor stub
		super("轮盘赌+精英选择策略");
	}
	public long getMaxGeneration() {
		return maxGeneration;
	}
	public void setMaxGeneration(long maxGeneration) {
		this.maxGeneration = maxGeneration;
	}
	@Override
	public Population select(Deque<Population> population) {
		// TODO Auto-generated method stub
		Population lastPopulation=population.getLast();
		float sumFitness=addFitness(lastPopulation);
		List<Float> probability=calculateProbability(lastPopulation, sumFitness);
		calculateCumulative(probability);
		Population newPopulation=createNewPopulation(lastPopulation, probability);
		return newPopulation;
	}
	private float addFitness(Population population){
		float sum=0;
		for(Individual individual:population.getIndividuals())
			sum+=individual.getFitness();
		return sum;
	}
	private List<Float> calculateProbability(Population population,float sum){
		float divide;
		List<Float> floatList=new ArrayList<Float>(population.getIndividuals().size());
		for(Individual individual:population.getIndividuals()){
			divide=individual.getFitness()/sum;
			floatList.add(divide);
		}
		return floatList;
	}
	private List<Float> calculateCumulative(List<Float> probability){
		float sum=0;
		for(int i=0;i<probability.size();i++){
			sum+=probability.get(i);
			probability.set(i, sum);
		}
		return probability;
	}
	private Population createNewPopulation(Population original,List<Float> cumulativeProbability){
		Population resultPopulation=new Population(original.getIndividuals().size());
		Individual bestIndividual=ObjectCopy.newInstance(original.getBestIndividual());
		resultPopulation.addIndividual(bestIndividual);
		Random random=new Random();
		int position;
		Individual insertedIndividual;
		for(int i=1;i<cumulativeProbability.size();i++){
			position=search(cumulativeProbability, random.nextFloat());
			insertedIndividual=ObjectCopy.newInstance(original.getIndividuals().get(position));
			resultPopulation.addIndividual(insertedIndividual);
		}
		return resultPopulation;
	}
	private int search(List<Float> floats,float random){
		for(int i=0;i<floats.size();i++){
			if(random<=floats.get(i))
				return i;
		}
		return floats.size()-1;
	}
}
domain\service\input\DefaultGepInput.java
package domain.service.input;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import jxl.Sheet;
import jxl.Workbook;
import jxl.read.biff.BiffException;
import domain.core.algmodel.genecomponent.Variable;
import domain.core.inputmodel.DataRow;
import domain.core.inputmodel.DataTable;
public class DefaultGepInput implements IgepInput {
	private File Path;
	
	public DefaultGepInput(){
		
	}
	@Override
	public void setFile(File path) {
		// TODO Auto-generated method stub
		Path=path;
	}
	@Override
	public void read(DataTable input) throws BiffException, IOException {
		// TODO Auto-generated method stub
		InputStream is = new FileInputStream(Path);
		// 声名一个工作薄
		Workbook rwb = Workbook.getWorkbook(is);
		// 获得工作薄的个数
		rwb.getNumberOfSheets();
		// 在Excel文档中，第一张工作表的缺省索引是0
		Sheet st = rwb.getSheet(0);
		// 通用的获取cell值的方式,getCell(int column, int row) 行和列
		
		
		
		
		
		int Rows = st.getRows();
		int Cols = st.getColumns();
		for (int i = 0; i < Cols; i++) {
			input.addColumn(st.getCell(i, 0).getContents());
			System.out.println(st.getCell(i, 0).getContents());
		}
		
		
		try {
		
			for (int i = 1; i < Rows; i++) {
				DataRow row = input.newRow();
				for(int j=0;j<Cols;j++){
					row.setValue(j, Float.valueOf(st.getCell(j, i).getContents()));
					System.out.print(row.getValue(j) + "		");
					
					
					
				}
					input.addRow(row);
					System.out.println();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
}
domain\service\input\DefaultGepInputTest.java
package domain.service.input;
import static org.junit.Assert.*;
import java.io.IOException;
import jxl.read.biff.BiffException;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import domain.core.inputmodel.DataTable;
public class DefaultGepInputTest {
	@Before
	public void setUp() throws Exception {
	}
	@After
	public void tearDown() throws Exception {
	}
	@Test
	public void testRead() {
		IgepInput di = new DefaultGepInput();
		DataTable dt = new DataTable();
		try {
			di.read(dt);
		} catch (BiffException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		
		
		
	}
}
domain\service\input\GepInputService.java
package domain.service.input;
import java.io.File;
import java.io.IOException;
import jxl.read.biff.BiffException;
import domain.iservice.IgepInputService;
/*
public class GepInputService implements IgepInputService {
	private IgepInput input=new DefaultGepInput();
	@Override
	public void uploadFile(InputSet set, File file) throws IOException,BiffException {
		// TODO Auto-generated method stub
		input.setFile(file);
		input.read(set);
	}
	
}
*/
domain\service\input\IgepInput.java
package domain.service.input;
import java.io.File;
import java.io.IOException;
import jxl.read.biff.BiffException;
import domain.core.inputmodel.DataTable;
public interface IgepInput {
	/**
	 * 设置输入路径
	 * @param path 输入路径
	 * @author 陈通
	 */
	void setFile(File path);
	/**
	 * 读取文件,将结果放入input中
	 * @param input 结果放入这里
	 * @author 陈通
	 * @throws BiffException 
	 */
	void read(DataTable input) throws IOException, BiffException;
}
domain\service\output\DefalutGepOutput.java
package domain.service.output;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import javax.swing.ImageIcon;
import com.wolfram.jlink.KernelLink;
import com.wolfram.jlink.MathCanvas;
import jxl.Workbook;
import jxl.write.Label;
import jxl.write.NumberFormats;
import jxl.write.WritableCellFormat;
import jxl.write.WritableSheet;
import jxl.write.WritableWorkbook;
import jxl.write.WriteException;
import domain.core.algmodel.configuration.Individual;
import domain.core.inputmodel.DataTable;
import domain.core.outputmodel.AlgInstance;
import domain.core.outputmodel.OutputIndividual;
import domain.core.outputmodel.OutputPopulation;
import domain.service.alg.configuration.Calculator;
import exception.IllegalInputSet;
public class DefalutGepOutput implements IgepOutput{
	
	private long start=-1;
	private long end=5;
	@Override
	public void setRange(long start, long end) {
		// TODO Auto-generated method stub
		this.start=start;
		this.end=end;
	}
	@Override
	public void setRange(long end) {
		// TODO Auto-generated method stub
		this.end=end;
	}
	@Override
	public void writeExcel(File path, AlgInstance output) throws IOException,
			WriteException {
		// TODO Auto-generated method stub
			//String filepath="OutputDemo.xls";
			String[] title ={"ID:","runTimes:","totalGeneration:","headerLength","normalgeneNums:","代数"};
			WritableWorkbook wwb;
			OutputStream os=new FileOutputStream(path);
			wwb=Workbook.createWorkbook(os);
			WritableSheet sheet=wwb.createSheet("子代详细信息", 0);
			sheet.setColumnView(0, 20); // 设置列的宽度
			sheet.setColumnView(1, 40);
			WritableCellFormat wc = new WritableCellFormat(); // 单元格定义
			wc.setAlignment(jxl.format.Alignment.RIGHT); // 设置对齐方式
			wc.setWrap(true);
			Label label;
			for(int i=0;i<title.length;i++){
				label=new Label(0,i,title[i]);
				sheet.addCell(label);
			}
			jxl.write.Number numberid=new jxl.write.Number(1,0,output.getGepConfiguration().getId());
			sheet.addCell(numberid);
			jxl.write.Number numbertimes=new jxl.write.Number(1,1,output.getRunTimes());
			sheet.addCell(numbertimes);
			jxl.write.Number numbergene=new jxl.write.Number(1,2,output.getTotalGeneration());
			sheet.addCell(numbergene);
			jxl.write.Number numberlen=new jxl.write.Number(1,3,Double.parseDouble(output.getGepConfiguration().getNormalHeaderLength()));
			sheet.addCell(numberlen);
			jxl.write.Number numbergenenums=new jxl.write.Number(1,4,Integer.parseInt(output.getGepConfiguration().getNormalGeneNumber()));
			sheet.addCell(numbergenenums);
			
			label=new Label(1,6,"最佳个体");
			sheet.addCell(label);
			label=new Label(2,6,"适应值");
			sheet.addCell(label);
			int i=7;
			int j=0;
			for(OutputPopulation p:output.getPopulationSet()){
				if(this.start!=-1&&this.end!=-1){
					if(j>=this.start&&j<this.end){
						jxl.write.Number daishu=new jxl.write.Number(0,i,p.getGeneration());
						sheet.addCell(daishu);
						OutputIndividual bestIndividual=p.getIndvididualSet().iterator().next();
						for(OutputIndividual individual:p.getIndvididualSet())
							if(bestIndividual.getFitness()<individual.getFitness())
								bestIndividual=individual;
						label=new Label(1,i,bestIndividual.getExpression(),wc);
						sheet.addCell(label);
						WritableCellFormat floatFormat = new WritableCellFormat (NumberFormats.FLOAT);			 
						//Number number3 = new Number(1, 4, 3.141519, floatFormat);
					    // 填充产品价格
					    jxl.write.Number nb = new jxl.write.Number(2, i,bestIndividual.getFitness(),floatFormat);
					    sheet.addCell(nb);
					    i++;
					}
				}
				
				if(this.start==-1&&this.end!=-1){
					if(j>output.getTotalGeneration()-this.end){
						jxl.write.Number daishu=new jxl.write.Number(0,i,p.getGeneration());
						sheet.addCell(daishu);
						OutputIndividual bestIndividual=p.getIndvididualSet().iterator().next();
						for(OutputIndividual individual:p.getIndvididualSet())
							if(bestIndividual.getFitness()<individual.getFitness())
								bestIndividual=individual;
						label=new Label(1,i,bestIndividual.getExpression(),wc);
						sheet.addCell(label);
						WritableCellFormat floatFormat = new WritableCellFormat (NumberFormats.FLOAT);			 
						//Number number3 = new Number(1, 4, 3.141519, floatFormat);
					    // 填充产品价格
					    jxl.write.Number nb = new jxl.write.Number(2, i,bestIndividual.getFitness(),floatFormat);
					    sheet.addCell(nb);
					    i++;
					}
				}
				j++;
			}
			
			 wwb.write();
		      // 关闭文件
		      wwb.close();
		}
	@Override
	/**
	 * 最佳个体的拟合曲线图
	 * @author 滕凌哲
	 */
	public MathCanvas drawImageA(Calculator calculator, Individual individual,KernelLink ml) {
		MathCanvas mathCanvasA = new MathCanvas(ml);
		DataTable inputSet = calculator.getInputSet();
		
		
		
		//List<Float> resultList = new ArrayList<Float>(inputSet.getRows().size()-1);	//用户输入集的List
		List<Float> resultList = inputSet.getColumnValue(inputSet.getColumns().size()-1);
		List<Float> caledList = null;	//经过计算后得到的List
		try {
			caledList = calculator.calculateInputSet(individual);
		} catch (IllegalInputSet e) {
			e.printStackTrace();
		}
		
		StringBuffer oldStr = new StringBuffer();
		StringBuffer newStr = new StringBuffer();
		
		oldStr.append("o={");
		newStr.append("n={");
		
		for (int i = 0; i < inputSet.getRows().size(); i++) {
			
			oldStr.append(resultList.get(i)+",");
			newStr.append(caledList.get(i)+",");
		}
		
		
		oldStr.delete(oldStr.length()-2, oldStr.length());
		newStr.delete(newStr.length()-2, newStr.length());
		
		oldStr.append("};");
		newStr.append("};");
		
		String str = "MultipleListPlot[o, n, PlotJoined -> True,AxesLabel -> {样本数, 拟合值}, GridLines -> Automatic, PlotLabel -> Style[Framed[最佳个体的拟合曲线图], 16, Blue, Background -> Lighter[Yellow]]]";
		
		mathCanvasA.setMathCommand("<< Graphics`MultipleListPlot`");
		mathCanvasA.setMathCommand(oldStr.toString()+newStr.toString()+str);
		
		
		return mathCanvasA;
	}
	
	
	@Override
	/**
	 * 每代最佳个体、最差个体的演化曲线图
	 * @author 滕凌哲
	 */
	public MathCanvas drawImageB(AlgInstance output,KernelLink ml) {
		MathCanvas mathCanvasB = new MathCanvas(ml);
		
		Set<OutputPopulation> popSet = output.getPopulationSet();
		//StringBuffer generationStr = new StringBuffer();
		StringBuffer bestStr = new StringBuffer();
		StringBuffer worseStr = new StringBuffer();
		
		//generationStr.append("x={");
		bestStr.append("yb={");
		worseStr.append("yw={");
		
		//System.out.println("最差个体：");
		
		
		Iterator<OutputPopulation> iterator = popSet.iterator();
		while (iterator.hasNext()) {
			OutputPopulation outputPopulation = (OutputPopulation) iterator.next();
			//generationStr.append(outputPopulation.getGeneration() + ",");
			bestStr.append(outputPopulation.getBestOutputIndividual().getFitness() + ",");
			worseStr.append(outputPopulation.getWorstOutputIndividual().getFitness() + ",");
			//System.out.println(outputPopulation.getWorstOutputIndividual().getFitness());
		}
		//generationStr.delete(generationStr.length()-2, generationStr.length());
		bestStr.delete(bestStr.length()-2, bestStr.length());
		worseStr.delete(worseStr.length()-2, worseStr.length());
		
		//generationStr.append("};");
		bestStr.append("};");
		worseStr.append("};");
		
		String str = "MultipleListPlot[yb, yw, PlotJoined -> True,AxesLabel -> {代数, 适应值}, GridLines -> Automatic, PlotLabel -> Style[Framed[每代最佳个体、最差个体的演化曲线图], 16, Blue, Background -> Lighter[Yellow]]]";
		
		mathCanvasB.setMathCommand("<< Graphics`MultipleListPlot`");
		mathCanvasB.setMathCommand(bestStr.toString()+worseStr.toString()+str);
		
		
		
		return mathCanvasB;
	}
	
}
domain\service\output\GepOutputService.java
package domain.service.output;
import java.io.File;
import java.io.IOException;
import javax.swing.ImageIcon;
import jxl.write.WriteException;
import domain.core.algmodel.configuration.Individual;
import domain.core.outputmodel.AlgInstance;
import domain.iservice.IgepOutputService;
import domain.service.alg.configuration.Calculator;
public class GepOutputService implements IgepOutputService {
	private IgepOutput igepOutput=new DefalutGepOutput();
	@Override
	public void setImplement(File path) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void setGeneration(long generation) {
		// TODO Auto-generated method stub
		igepOutput.setRange(generation);
	}
	@Override
	public void setGeneration(long start, long end) {
		// TODO Auto-generated method stub
		igepOutput.setRange(start, end);
	}
	@Override
	public void writeExcel(AlgInstance set, File path) throws IOException,
			WriteException {
		// TODO Auto-generated method stub
//		igepOutput.writeExcel(path, set);
	}
	@Override
	public ImageIcon drawImage(AlgInstance outPut) {
		// TODO Auto-generated method stub
		return null;
	}
	@Override
	public ImageIcon drawImage(Calculator calculator, Individual individual) {
		// TODO Auto-generated method stub
		return null;
	}
}
domain\service\output\IgepOutput.java
package domain.service.output;
import java.io.File;
import java.io.IOException;
import javax.swing.ImageIcon;
import com.wolfram.jlink.KernelLink;
import com.wolfram.jlink.MathCanvas;
import jxl.write.WriteException;
import domain.core.algmodel.configuration.Individual;
import domain.core.outputmodel.AlgInstance;
import domain.service.alg.configuration.Calculator;
public interface IgepOutput {
	/**
	 * 设置输出代数，从start代到end代的结果,这个方法只影响写excel文件，不影响画函数图像与写数据库
	 * @param start 开始输出的代数，包括
	 * @param end 结束输出的代数，不包括
	 * @author 张开活
	 */
	void setRange(long start,long end);
	/**
	 * 设置输出代数，输出最后end代，这个方法只影响写excel文件，不影响画函数图像与写数据库
	 * @param end 输出最后end代
	 * @author 张开活
	 */
	void setRange(long end);
	/**
	 * 根据输出代数将结果写到excel中
	 * @param path 输出文件路径
	 * @param output 待输出的结果结合
	 * @author 张开活
	 * @throws WriteException 
	 */
	void writeExcel(File path,AlgInstance output) throws IOException, WriteException;
	
	
	
	/**
	 * 画拟合曲线图
	 * @param output
	 * @return MathCanvas对象
	 */
	public MathCanvas drawImageA(Calculator calculator, Individual individual,KernelLink ml);
	
	/**
	 * 画每代最佳个体、最差个体的演化曲线图
	 * @param output
	 * @return MathCanvas对象
	 */
	public MathCanvas drawImageB(AlgInstance output,KernelLink ml);
	
	
}
exception\Duplicated.java
package exception;
public class Duplicated extends Exception {
	/**
	 * 
	 */
	private static final long serialVersionUID = 8940856307517070718L;
}
exception\IllegalInputSet.java
package exception;
public class IllegalInputSet extends Exception {
	/**
	 * 
	 */
	private static final long serialVersionUID = -2292135742688459906L;
}
test\ConfigurationTest.java
package test;
import java.io.IOException;
import java.util.List;
import jxl.read.biff.BiffException;
import domain.core.algmodel.genecomponent.Function;
import domain.core.outputmodel.GepConfiguration;
import domain.iservice.IgepAlgService;
import domain.service.alg.configuration.GepAlgService;
public class ConfigurationTest {
	public static void main(String argv[]) throws BiffException, ClassNotFoundException, InstantiationException, IllegalAccessException, IOException{
		IgepAlgService myGepService=iniAlg();
		System.out.println(myGepService.getAvailableCalculator().get(0).toString());
		System.out.println(myGepService.getAvailableCreator().get(0).toString());
		System.out.println(myGepService.getAvailableFunctions().get(0).toString());
		System.out.println(myGepService.getAvailableFunctions().get(1).toString());
		System.out.println(myGepService.getAvailableFunctions().get(2).toString());
		System.out.println(myGepService.getAvailableFunctions().get(3).toString());
		System.out.println(myGepService.getAvailableModifyings().get(0).toString());
		System.out.println(myGepService.getAvailableSelector().get(0).toString());
	}
	static IgepAlgService iniAlg() throws BiffException, IOException, ClassNotFoundException, InstantiationException, IllegalAccessException{
		GepConfiguration myParameter=new GepConfiguration();
		myParameter.setInputFile("InputDemo.xls");
		myParameter.setName("测试123333");
		myParameter.setAccuray("0.01");
		myParameter.setNormalGeneNumber("3");
		myParameter.setGeneRecombineRate("0.1");
		myParameter.setGeneTransportRate("0.1");
		myParameter.setNormalHeaderLength("7");
		myParameter.setIsTransportRate("0.1");
		myParameter.setMaxGeneration("100000");
		myParameter.setOnePointRecombineRate("0.4");
		myParameter.setPopulationSize("20");
		myParameter.setRisTransportRate("0.1");
		myParameter.setSelectionRange("100");
		myParameter.setTwoPointRecombineRate("0.2");
		myParameter.setMutateRate("0.044");
		myParameter.setIsElement("1,2,3");
		myParameter.setRisElement("1,2,3");
		myParameter.setHomeoticGeneNumber("1");
		myParameter.setHomeoticHeaderLength("5");
		myParameter.setRandomConstantStart("0");
		myParameter.setRandomConstantEnd("1");
		myParameter.setConstantListSize("10");
		IgepAlgService myGepService=new GepAlgService();	
		myParameter.setCreator(myGepService.getAvailableCreator().get(0).getClass().getName());
		myParameter.setCalculator(myGepService.getAvailableCalculator().get(0).getClass().getName());
		myParameter.setModify(myGepService.getAvailableModifyings().get(0).getClass().getName());
		myParameter.setFunctionList(getFunctionList(myGepService));
		myParameter.setSelector(myGepService.getAvailableSelector().get(0).getClass().getName());
		myGepService.setParameters(myParameter);
		return myGepService;
	}
	private static String getFunctionList(IgepAlgService myGepService) throws ClassNotFoundException, InstantiationException, IllegalAccessException{
		List<Function> myFunction=myGepService.getAvailableFunctions();
		StringBuffer result=new StringBuffer();
		for(Function function:myFunction)
			result.append(function.getClass().getName()+",");
		return result.toString();
	}
}
test\CreatePopulation.java
package test;
import java.io.File;
import java.io.IOException;
import jxl.read.biff.BiffException;
import jxl.write.WriteException;
import domain.core.algmodel.configuration.GepAlgorithm;
import domain.core.algmodel.configuration.Individual;
import domain.core.algmodel.configuration.Population;
import domain.iservice.IgepAlgService;
import domain.iservice.IgepOutputService;
import domain.service.output.GepOutputService;
public class CreatePopulation {
	/**
	 * @param args
	 * @throws IOException 
	 * @throws BiffException 
	 * @throws IllegalAccessException 
	 * @throws InstantiationException 
	 * @throws ClassNotFoundException 
	 * @throws WriteException 
	 */
	public static void main(String[] args) throws BiffException, IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, WriteException {
		// TODO Auto-generated method stub
		IgepAlgService myGepService=ConfigurationTest.iniAlg();
		myGepService.run();
		IgepOutputService output=new GepOutputService();
		/*
		 * 写excel文件
		 */
		output.setGeneration(0,10);
		output.writeExcel(myGepService.getMyAlgInstance(), new File("Outputdemo.xls"));
		myGepService.getMyAlgInstance();
		/*
		Field[] myGepAlgFields=GepAlgService.class.getDeclaredFields();
		for(Field myGepAlg:myGepAlgFields)
			if(myGepAlg.getName().equals("myGepAlgorithm")){
				myGepAlg.setAccessible(true);
				test((GepAlgorithm)myGepAlg.get(myGepService));
				break;
			}
			*/
	}
	static void test(GepAlgorithm algorithm){
		System.out.println("同源染色体长度"+algorithm.getHomeoticGeneLength());
		System.out.println("同源染色体数量"+algorithm.getHomeoticGeneNumber());
		System.out.println("同源染色体头长"+algorithm.getHomeoticHeaderLength());
		System.out.println("同源染色体尾长"+algorithm.getHomeoticTailLength());
		System.out.println("正常基因常长度"+algorithm.getNormalGeneLength());
		System.out.println("正常基因数量"+algorithm.getNormalGeneNumber());
		System.out.println("正常基因头长"+algorithm.getNormalHeaderLength());
		System.out.println("正常基因尾长"+algorithm.getNormalTailLength());
		Population myPopulation=algorithm.getPopulationQueue().getLast();
		System.out.println("代数"+myPopulation.getGeneration());
		for(Individual individual:myPopulation.getIndividuals())
			System.out.println(individual);
	}
}
test\CreatorTest.java
package test;
import java.util.ArrayList;
import java.util.List;
import domain.core.algmodel.configuration.GepAlgorithm;
import domain.core.algmodel.configuration.Individual;
import domain.core.algmodel.configuration.Population;
import domain.core.algmodel.genecomponent.Constant;
import domain.core.algmodel.genecomponent.GenePiece;
import domain.core.algmodel.genecomponent.Variable;
import domain.service.alg.configuration.Creator;
import domain.service.alg.userdefined.function.Additioin;
import domain.service.alg.userdefined.function.Divide;
import domain.service.alg.userdefined.function.Minus;
import domain.service.alg.userdefined.function.Multiply;
/**
 * 需要把此类保存到对应的文件夹中才可运行
 */
public class CreatorTest extends Creator{
	public CreatorTest() {
		super("测试Create");
		// TODO Auto-generated constructor stub
	}
	@Override
	public void create(GepAlgorithm algorithm) {
		// TODO Auto-generated method stub
		Population population=new Population(algorithm.getPopulationSize());
		Individual individual=new Individual();
		List<GenePiece> genePieces=new ArrayList<GenePiece>();
		Variable variable=new Variable();
		variable.setName("a");
		variable.setSymbol("a");
		//正常基因
		genePieces.add(new Divide());
		genePieces.add(new Additioin());
		genePieces.add(new Minus());
		genePieces.add(new Multiply());
		genePieces.add(new Multiply());
		genePieces.add(new Multiply());
		genePieces.add(new Minus());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(new Additioin());
		genePieces.add(variable.copy());
		genePieces.add(new Divide());
		genePieces.add(variable.copy());
		genePieces.add(new Divide());
		genePieces.add(new Additioin());
		genePieces.add(new Multiply());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(new Multiply());
		genePieces.add(new Minus());
		genePieces.add(new Multiply());
		genePieces.add(new Minus());
		genePieces.add(variable.copy());
		genePieces.add(new Multiply());
		genePieces.add(new Minus());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		
		//同源基因
		genePieces.add(new Additioin());
		genePieces.add(new Additioin());
		Constant constant=new Constant(algorithm.getNormalGeneNumber());
		while(((int)constant.getValue())!=2)
			constant=new Constant(algorithm.getNormalGeneNumber());
		genePieces.add(constant);
		while(((int)constant.getValue())!=1)
			constant=new Constant(algorithm.getNormalGeneNumber());
		genePieces.add(constant);
		while(((int)constant.getValue())!=0)
			constant=new Constant(algorithm.getNormalGeneNumber());
		genePieces.add(constant);
		genePieces.add(new Constant(algorithm.getNormalGeneNumber()));
		genePieces.add(new Constant(algorithm.getNormalGeneNumber()));
		genePieces.add(new Constant(algorithm.getNormalGeneNumber()));
		genePieces.add(new Constant(algorithm.getNormalGeneNumber()));
		genePieces.add(new Constant(algorithm.getNormalGeneNumber()));
		genePieces.add(new Constant(algorithm.getNormalGeneNumber()));
		genePieces.add(new Constant(algorithm.getNormalGeneNumber()));
		genePieces.add(new Constant(algorithm.getNormalGeneNumber()));
		genePieces.add(new Constant(algorithm.getNormalGeneNumber()));
		genePieces.add(new Constant(algorithm.getNormalGeneNumber()));
		genePieces.add(new Constant(algorithm.getNormalGeneNumber()));
		genePieces.add(new Constant(algorithm.getNormalGeneNumber()));
		
		
		individual.setContainedGenePieces(genePieces, 
				algorithm.getNormalGeneNumber(), 
				algorithm.getNormalHeaderLength(), 
				algorithm.getNormalGeneLength(),
				algorithm.getHomeoticGeneNumber(), 
				algorithm.getHomeoticHeaderLength(), 
				algorithm.getHomeoticGeneLength());
		for(int i=0;i<algorithm.getPopulationSize();i++)
			population.addIndividual(individual.copy());
		algorithm.addPopulation(population);
	}
}
test\FitnessTest.java
package test;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.List;
import jxl.read.biff.BiffException;
import domain.core.algmodel.configuration.GepAlgorithm;
import domain.core.algmodel.configuration.Individual;
import domain.iservice.IgepAlgService;
import domain.service.alg.configuration.GepAlgService;
public class FitnessTest {
	/**
	 * @param args
	 * @throws IOException 
	 * @throws IllegalAccessException 
	 * @throws InstantiationException 
	 * @throws ClassNotFoundException 
	 * @throws BiffException 
	 */
	public static void main(String[] args) throws BiffException, ClassNotFoundException, InstantiationException, IllegalAccessException, IOException {
		// TODO Auto-generated method stub
		IgepAlgService myGepService=ConfigurationTest.iniAlg();
		myGepService.run();
		Field[] myGepAlgFields=GepAlgService.class.getDeclaredFields();
		for(Field myGepAlg:myGepAlgFields)
			if(myGepAlg.getName().equals("myGepAlgorithm")){
				myGepAlg.setAccessible(true);
				test((GepAlgorithm)myGepAlg.get(myGepService));
				break;
			}
	}
	private static void test(GepAlgorithm gepAlgorithm){
		System.out.println(gepAlgorithm.getPopulationQueue().getFirst().getBestIndividual().getFitness());
		List<Individual> individuals=gepAlgorithm.getPopulationQueue().getFirst().getIndividuals();
		System.out.println("_______________________________");
		for(Individual individual:individuals){
			System.out.println(individual.getFitness());
		}
		System.out.println("_______________________________");
	}
	
}
test\GenePieceCopyTest.java
package test;
import domain.core.algmodel.genecomponent.GenePiece;
import domain.service.alg.userdefined.function.Additioin;
public class GenePieceCopyTest {
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		GenePiece genePiece=new Additioin();
		genePiece.setSymbol("00");
		GenePiece genePiece2=genePiece.copy();
		genePiece2.setSymbol("10");
		System.out.println(genePiece.getSymbol());
		System.out.println(genePiece2.getSymbol());
	}
}
test\IndividualCopyTest.java
package test;
import java.util.ArrayList;
import java.util.List;
import domain.core.algmodel.configuration.Individual;
import domain.core.algmodel.genecomponent.Constant;
import domain.core.algmodel.genecomponent.GenePiece;
import domain.core.algmodel.genecomponent.Variable;
import domain.service.alg.userdefined.function.Additioin;
import domain.service.alg.userdefined.function.Divide;
import domain.service.alg.userdefined.function.Minus;
import domain.service.alg.userdefined.function.Multiply;
public class IndividualCopyTest {
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Individual individual=new Individual();
		List<GenePiece> genePieces=new ArrayList<GenePiece>();
		Variable variable=new Variable();
		variable.setName("a");
		variable.setSymbol("a");
		//正常基因
		genePieces.add(new Divide());
		genePieces.add(new Additioin());
		genePieces.add(new Minus());
		genePieces.add(new Multiply());
		genePieces.add(new Multiply());
		genePieces.add(new Multiply());
		genePieces.add(new Minus());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(new Additioin());
		genePieces.add(variable.copy());
		genePieces.add(new Divide());
		genePieces.add(variable.copy());
		genePieces.add(new Divide());
		genePieces.add(new Additioin());
		genePieces.add(new Multiply());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(new Multiply());
		genePieces.add(new Minus());
		genePieces.add(new Multiply());
		genePieces.add(new Minus());
		genePieces.add(variable.copy());
		genePieces.add(new Multiply());
		genePieces.add(new Minus());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		genePieces.add(variable.copy());
		
		//同源基因
		genePieces.add(new Additioin());
		genePieces.add(new Additioin());
		Constant constant=new Constant(3);
		while(((int)constant.getValue())!=2)
			constant=new Constant(3);
		genePieces.add(constant);
		while(((int)constant.getValue())!=1)
			constant=new Constant(3);
		genePieces.add(constant);
		while(((int)constant.getValue())!=0)
			constant=new Constant(3);
		genePieces.add(constant);
		genePieces.add(new Constant(3));
		genePieces.add(new Constant(3));
		genePieces.add(new Constant(3));
		genePieces.add(new Constant(3));
		genePieces.add(new Constant(3));
		genePieces.add(new Constant(3));
		genePieces.add(new Constant(3));
		genePieces.add(new Constant(3));
		genePieces.add(new Constant(3));
		genePieces.add(new Constant(3));
		genePieces.add(new Constant(3));
		genePieces.add(new Constant(3));
		individual.setContainedGenePieces(genePieces, 3, 7, 15, 1, 7, 15);
		System.out.println(individual);
		Individual individual2=individual.copy();
		individual.getContainedGenePieces().set(0, new Additioin());
		System.out.println(individual);
		System.out.println(individual2);
	}
}
test\InputTest.java
package test;
import java.io.File;
import java.io.IOException;
import jxl.read.biff.BiffException;
import domain.service.input.DefaultGepInput;
import domain.service.input.IgepInput;
/**public class InputTest {
	
	 * @param args
	 * @throws IOException 
	 * @throws BiffException 
	 
	public static void main(String[] args) throws BiffException, IOException {
		// TODO Auto-generated method stub
		IgepInput input =new DefaultGepInput();
		InputSet is = new InputSet();
		File path=new File("InputDemo.xls");
		input.setFile(path);
		input.read(is);
		int row=is.getFieldRowList().size();
		int col=is.getVariableRow().getColumns();	
		for (int i=0;i<col;i++)
		{
			System.out.print(is.getVariableRow().getVariableList().get(i).getName()+" ");
		}
		System.out.println();
		for(int i=0;i<row;i++){
			for(int j=0;j<col;j++)
				{
				System.out.print(is.getFieldRowList().get(i).getFieldItemList().get(j).getValue()+" "+is.getFieldRowList().get(i).getFieldItemList().get(j).getName()+"\t");
				}
			System.out.println();
		}
	}
}*/
tool\Directory.java
package tool;
import java.util.regex.*;
import java.io.*;
import java.util.*;
public final class Directory {
	
	public static File[] local(File dir, final String regex) {
		return dir.listFiles(new FilenameFilter() {
			private Pattern pattern = Pattern.compile(regex);
			public boolean accept(File dir, String name) {
				return pattern.matcher(new File(name).getName()).matches();
			}
		});
	}
	public static File[] local(String path, final String regex) { // Overloaded
		return local(new File(path), regex);
	}
	// A two-tuple for returning a pair of objects:
	public static class TreeInfo implements Iterable<File> {
		public List<File> files = new ArrayList<File>();
		public List<File> dirs = new ArrayList<File>();
		// The default iterable element is the file list:
		public Iterator<File> iterator() {
			return files.iterator();
		}
		void addAll(TreeInfo other) {
			files.addAll(other.files);
			dirs.addAll(other.dirs);
		}
		public String toString() {
			return "dirs: " + dirs + "\n\nfiles: " + files;
		}
	}
	public static TreeInfo walk(String start, String regex) { // Begin recursion
		return recurseDirs(new File(start), regex);
	}
	public static TreeInfo walk(File start, String regex) { // Overloaded
		return recurseDirs(start, regex);
	}
	public static TreeInfo walk(File start) { // Everything
		return recurseDirs(start, ".*");
	}
	public static TreeInfo walk(String start) {
		return recurseDirs(new File(start), ".*");
	}
	static TreeInfo recurseDirs(File startDir, String regex) {
		TreeInfo result = new TreeInfo();
		for (File item : startDir.listFiles()) {
			if (item.isDirectory()) {
				result.dirs.add(item);
				result.addAll(recurseDirs(item, regex));
			} else // Regular file
			if (item.getName().matches(regex))
				result.files.add(item);
		}
		return result;
	}
	// Simple validation test:
	public static void main(String[] args) {
		if (args.length == 0)
			System.out.println(walk("."));
		else
			for (String arg : args)
				System.out.println(walk(arg));
	}
}
tool\HibernateSchemaExport.java
package tool;
import java.io.File;
import org.hibernate.HibernateException;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.tool.hbm2ddl.SchemaExport;
public class HibernateSchemaExport {
	static Session session;
	static Configuration config = null;
	static Transaction tx = null;
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/** 
		/**
		 * 根据映射文件创建数据库结构
		 */
		SessionFactory sessionFactory=null;
		try {
			config = new Configuration().configure(new File(
					"src/data/configure/hibernate.cfg.xml"));
			System.out.println("Creating tables...");
			sessionFactory = config.buildSessionFactory();
			session = sessionFactory.openSession();
			SchemaExport schemaExport = new SchemaExport(config);
			schemaExport.setOutputFile("src\\data\\sql\\sql.sql");
			schemaExport.setFormat(true);
			schemaExport.setHaltOnError(true);
			schemaExport.create(true, true);
			System.out.println("Table created.");
			session.flush();
		} 
		catch (HibernateException e)
		{
			e.printStackTrace();
			tx.rollback();
			
		}
		catch (Exception e)
		{
			e.printStackTrace();	
		}
		finally 
		{
			session.close();
			sessionFactory.close();
			
		}
	}
}
tool\MergeFile.java
package tool;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Iterator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class MergeFile {
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Iterator<File> allFile=Directory.walk("src",".+java").iterator();
		File mergedFile=new File("merged.txt");
		File nextFile;
		BufferedWriter bufferedWriter;
		String contextString;
		try {
			bufferedWriter=new BufferedWriter(new FileWriter(mergedFile));
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			System.out.println("目标文件无法打开");
			e1.printStackTrace();
			return;
		}
		while(allFile.hasNext()){
			nextFile=allFile.next();
			if(nextFile.exists()){
				try {
					contextString=readFileToString(nextFile);
					writeToFile(bufferedWriter, contextString);
				} catch (FileNotFoundException e) {
					// TODO Auto-generated catch block
					System.out.println("文件不存在");
					e.printStackTrace();
					continue;
				} catch (IOException e) {
					// TODO Auto-generated catch block
					System.out.println("无法打开文件");
					e.printStackTrace();
					continue;
				}
				//writeToFile(bufferedWriter, contextString);
			}
		}
	}
	private static String readFileToString(File file) throws IOException{
		BufferedReader bufferedReader=new BufferedReader(new FileReader(file));
		String s;
		StringBuilder stringBuilder=new StringBuilder();
		stringBuilder.append(file.getPath().substring(4)+"\n");
		
		//Pattern pattern = Pattern.compile("([\t]{1}|\n+|\r+|\r\n+)");
		Pattern pattern = Pattern.compile("(\r?\n(\\s*\r?\n)+)");
		while(true){
			if((s=bufferedReader.readLine())!=null){
				/*if (s.equals("")||s==null||s.equals(null)||s.equals("\r")||s.equals("	 ")||s.equals("\t")||s.equals("\t\t")||s.equals("\t\t\t")||s.equals("\t\t"+"  ")){
					
					
				}else {
					stringBuilder.append(s+"\n");
					continue;
				}*/
				
				if (s.equals("")) {
					
				}
				else {
					
					Matcher matcher = pattern.matcher(s);
					if (matcher.find()) {
						//System.out.println(matcher.group());
						//s.replaceAll("(\r?\n(\\s*\r?\n)+)", "\r\n"); 
						//s = matcher.replaceAll("\n");	//\r\n
						//System.out.print(s);
						
						
					}else{
						//System.out.println("no found");
						stringBuilder.append(s+"\n");
					}
				}
				
			}else{
				stringBuilder.deleteCharAt(stringBuilder.length()-1);
				break;
			}
		}
		return stringBuilder.toString();
	}
	private static boolean writeToFile(BufferedWriter bufferedWriter,String context){
		boolean result=true;
		try {
			bufferedWriter.write(context+"\n");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			result=false;
		}
		return result;
	}
}
ui\alg\controller\FunctionPanelController.java
package ui.alg.controller;
import java.util.ArrayList;
import javax.swing.JComboBox;
public class FunctionPanelController {
	static int addTime=0;
	static ArrayList<String> items = new ArrayList<String>();
    public static void functionComboBoxController(JComboBox comboBox,JComboBox JComboBoxOfSelectdFunctions){
    	boolean isaddItem = true;
		if (addTime == 0) {
			items.add(comboBox.getSelectedItem().toString());
			JComboBoxOfSelectdFunctions.addItem(comboBox
					.getSelectedItem().toString());
			JComboBoxOfSelectdFunctions.setSelectedItem(comboBox
					.getSelectedItem().toString());
		} 
		else {
			for (int i = 0; i < items.size(); i++) {
				String item = comboBox.getSelectedItem().toString();
				if (item.equals(items.get(i))) {
					isaddItem = false;
				}
	        }
			if (isaddItem == true) {
				items.add(comboBox.getSelectedItem().toString());
				JComboBoxOfSelectdFunctions.addItem(comboBox
						.getSelectedItem().toString());
				JComboBoxOfSelectdFunctions.setSelectedItem(comboBox
						.getSelectedItem().toString());
			}
		}
		addTime++;
	}
    
}
ui\alg\controller\HostPanelController.java
package ui.alg.controller;
import java.awt.event.ItemEvent;
import java.awt.event.KeyEvent;
import java.io.IOException;
import java.util.List;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import domain.core.outputmodel.GepConfiguration;
import domain.iservice.IgepAlgService;
import jxl.read.biff.BiffException;
import ui.alg.view.HostPanel;
import ui.alg.view.JPanelForFunction;
import ui.alg.view.JPanelForGene;
import ui.alg.view.JPanelForStopSetting;
import ui.alg.view.JPanelForPopulation;
import ui.input.view.*;
public class HostPanelController {
   
 
   
   
  
   
   public static void btnNext0Controller(DefaultMutableTreeNode node1,JTree tree_1, HostPanel configurationPanel,JPanelForStopSetting inputPathPanel) {
		
		TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node1));
		tree_1.setSelectionPath(visiblePath);
		configurationPanel.setVisible(false);
	    inputPathPanel.setVisible(true);
	   
	}
	public static void btnSetConfigController(DefaultMutableTreeNode node1,JTree tree_1, HostPanel configurationPanel,JPanelForStopSetting inputPathPanel) {
		TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node1));
		tree_1.setSelectionPath(visiblePath);
		configurationPanel.setVisible(false);
		inputPathPanel.setVisible(true);
		
	}
	public static String jcomboBoxItemController(ItemEvent ie,HostPanel configurationPanel,JPanelForStopSetting stopSettingPanel,
			JPanelForPopulation populationPanel,JPanelForGene genePanel,JPanelForFunction functionPanel,JPanelForFooter footerPanel,JPanelForInputFile  inputFilePanel,GepConfiguration myConfigurationFromDB,List<GepConfiguration> configurationsOfHistory,
			IgepAlgService myGepService) {
		
		if (ie.getStateChange()==ItemEvent.SELECTED){
	  		
	  		   footerPanel.setVisible(true);
	       	   configurationPanel.btnSetConfig.setVisible(false);
	       	   configurationPanel.setVisible(false);
	       	   stopSettingPanel.setVisible(true);
	    }
		return handler(configurationPanel, stopSettingPanel, populationPanel, genePanel, functionPanel,inputFilePanel, myConfigurationFromDB, configurationsOfHistory, myGepService);
   }
	public static void jcomboBoxEditorController(KeyEvent e,JButton btnSetConfig) {
		 if(e.getKeyCode() == KeyEvent.VK_ENTER){  
	        	btnSetConfig.setVisible(true);
	       }
		
	}
	
	public static String handler(HostPanel configurationPanel,JPanelForStopSetting stopSettingPanel,
		    JPanelForPopulation populationPanel,JPanelForGene genePanel,JPanelForFunction functionPanel,
		    JPanelForInputFile  inputFilePanel,
		    GepConfiguration myConfigurationFromDB,List<GepConfiguration> configurationsOfHistory,
		    IgepAlgService myGepService){
		    	
		    	inputFilePanel.txtInputPath.setText(myConfigurationFromDB.getInputFile());
				stopSettingPanel.txtAccuracy.setText(myConfigurationFromDB.getAccuray());
				functionPanel.txtConstantListSize.setText(myConfigurationFromDB.getConstantListSize());
				genePanel.txtGeneOnePointRecombineRate.setText(myConfigurationFromDB.getOnePointRecombineRate());
				genePanel.txtGeneRecombineRate.setText(myConfigurationFromDB.getGeneRecombineRate());
				genePanel.txtGeneTransportRate.setText(myConfigurationFromDB.getGeneTransportRate());
				genePanel.txtHomeoticGeneNums.setText(myConfigurationFromDB.getHomeoticGeneNumber());
				genePanel.txtHomeoticHeaderLength.setText(myConfigurationFromDB.getHomeoticHeaderLength());
				
				genePanel.txtIsTransportRate.setText(myConfigurationFromDB.getIsTransportRate());
				stopSettingPanel.txtMaxGeneration.setText(myConfigurationFromDB.getMaxGeneration());
				genePanel.txtMutateRate.setText(myConfigurationFromDB.getMutateRate());
				genePanel.txtNormalGeneNumber.setText(myConfigurationFromDB.getNormalGeneNumber());
				genePanel.txtNormalHeaderLength.setText(myConfigurationFromDB.getNormalHeaderLength());
				genePanel.txtofIsElement.setText(myConfigurationFromDB.getIsElement());
				genePanel.txtofRisElement.setText(myConfigurationFromDB.getRisElement());
				populationPanel.txtPopulationSize.setText(myConfigurationFromDB.getPopulationSize());
				functionPanel.txtRandomConstantStart.setText(myConfigurationFromDB.getRandomConstantStart());
				genePanel.txtRisTransportRate.setText(myConfigurationFromDB.getRisTransportRate());
				populationPanel.txtSelectionRange.setText(myConfigurationFromDB.getSelectionRange());
				genePanel.txtTwoPointRecombineRate.setText(myConfigurationFromDB.getTwoPointRecombineRate());
				
				String[] functions = myConfigurationFromDB.getFunctionList()
						.split(",");
				for (int i = 0; i < functions.length; i++) {
					System.out.println(functions[i].toString());
					if (functions[i].toString().equals("domain.service.alg.userdefined.function.Additioin")) {
					   functionPanel.JComboBoxOfSelectdFunctions.addItem("+");
					} else if (functions[i].toString().equals("domain.service.alg.userdefined.function.Minus")) {
						functionPanel.JComboBoxOfSelectdFunctions.addItem("-");
					} else if (functions[i].toString().equals("domain.service.alg.userdefined.function.Multiply")) {
						functionPanel.JComboBoxOfSelectdFunctions.addItem("*");
					} else {
						functionPanel.JComboBoxOfSelectdFunctions.addItem("/");
					}
				}
				populationPanel.JcomboBoxOfPopulationCreator.setSelectedItem(myConfigurationFromDB.getCreator());
				genePanel.JComboBoxOfAvailableModifyings.setSelectedItem(myConfigurationFromDB.getModify());
				populationPanel.JComboBoxAvailableCalculator.setSelectedItem(myConfigurationFromDB.getCalculator());
				configurationPanel.setVisible(false);
				stopSettingPanel.setVisible(true);
				stopSettingPanel.txtMaxGeneration.grabFocus();
				return null;
		    }
	public static void btnSetConfigController(JPanelForStopSetting stopSettingPanel,
		    JPanelForPopulation populationPanel,JPanelForGene genePanel,JPanelForFunction functionPanel,
		    JPanelForInputFile  inputFilePanel){
		    initialiseController(stopSettingPanel,populationPanel,genePanel,functionPanel,inputFilePanel);
	}
	private static void initialiseController(JPanelForStopSetting stopSettingPanel,JPanelForPopulation populationPanel, JPanelForGene genePanel,JPanelForFunction functionPanel, JPanelForInputFile inputFilePanel) {
		inputFilePanel.txtInputPath.setText("");
		stopSettingPanel.txtAccuracy.setText("");
		functionPanel.txtConstantListSize.setText("");
		genePanel.txtGeneOnePointRecombineRate.setText("");
		genePanel.txtGeneRecombineRate.setText("");
		genePanel.txtGeneTransportRate.setText("");
		genePanel.txtHomeoticGeneNums.setText("");
		genePanel.txtHomeoticHeaderLength.setText("");
		
		genePanel.txtIsTransportRate.setText("");
		stopSettingPanel.txtMaxGeneration.setText("");
		genePanel.txtMutateRate.setText("");
		genePanel.txtNormalGeneNumber.setText("");
		genePanel.txtNormalHeaderLength.setText("");
		genePanel.txtofIsElement.setText("");
		genePanel.txtofRisElement.setText("");
		populationPanel.txtPopulationSize.setText("");
		functionPanel.txtRandomConstantStart.setText("");
		genePanel.txtRisTransportRate.setText("");
		populationPanel.txtSelectionRange.setText("");
		genePanel.txtTwoPointRecombineRate.setText("");
		
	}
}
ui\alg\Model\ModelForJPanelConfig.java
package ui.alg.Model;
public class ModelForJPanelConfig {
    String configName;
    public ModelForJPanelConfig(String configName){
    	this.configName=configName;
    }
    public void setConfig(String config){
       configName=config;
    }
    public String getConfig(){
    	return this.configName;
    }
}
ui\alg\Model\ModelForJPanelFunction.java
package ui.alg.Model;
public class ModelForJPanelFunction {
  
   StringBuffer functions;
   
   public ModelForJPanelFunction(StringBuffer functions){
	   this.functions=functions;
   }
   public StringBuffer getFunctions() {
		return functions;
	}
	public void setFunctions(StringBuffer functions) {
		this.functions = functions;
	}
   
}
ui\alg\Model\ModelForJPanelGEne.java
package ui.alg.Model;
public class ModelForJPanelGEne {
	
	String normalGeneNumber;
    String normalHeaderLength;
    String homeoticGeneNums;
    String homeoticHeaderLength;
    String geneRecombineRate;
    String risTransportRate;
    String risElement;
    String isTransportRate;
    String isElement;
    String geneTransportRate;
    String mutateRate;
    String twoPointRecombineRate;
    String geneOnePointRecombineRate;
    int availableModifyingsIndex;
    public ModelForJPanelGEne(String normalGeneNumber,String normalHeaderLength,String homeoticGeneNums,String homeoticHeaderLength,String geneRecombineRate,
    		String risTransportRate,String risElement,String isTransportRate, String isElement,String geneTransportRate,String mutateRate,String twoPointRecombineRate,String geneOnePointRecombineRate,int availableModifyings){
    	this.normalGeneNumber= normalGeneNumber;
        this.normalHeaderLength=normalHeaderLength;
        this.homeoticGeneNums=homeoticGeneNums;
        this.homeoticHeaderLength= homeoticHeaderLength;
        this.geneRecombineRate=geneRecombineRate;
        this.risTransportRate=risTransportRate;
        this.risElement=risElement;
        this.isTransportRate=isTransportRate;
        this.isElement=isElement;
        this.geneTransportRate=geneTransportRate;
        this.mutateRate=mutateRate;
        this.twoPointRecombineRate=twoPointRecombineRate;
        this.geneOnePointRecombineRate=geneOnePointRecombineRate;
        this.availableModifyingsIndex=availableModifyings;
    	
    }
    public String getNormalGeneNumber() {
		return normalGeneNumber;
	}
	public void setNormalGeneNumber(String normalGeneNumber) {
		this.normalGeneNumber = normalGeneNumber;
	}
	public String getNormalHeaderLength() {
		return normalHeaderLength;
	}
	public void setNormalHeaderLength(String normalHeaderLength) {
		this.normalHeaderLength = normalHeaderLength;
	}
	public String getHomeoticGeneNums() {
		return homeoticGeneNums;
	}
	public void setHomeoticGeneNums(String homeoticGeneNums) {
		this.homeoticGeneNums = homeoticGeneNums;
	}
	public String getHomeoticHeaderLength() {
		return homeoticHeaderLength;
	}
	public void setHomeoticHeaderLength(String homeoticHeaderLength) {
		this.homeoticHeaderLength = homeoticHeaderLength;
	}
	public String getGeneRecombineRate() {
		return geneRecombineRate;
	}
	public void setGeneRecombineRate(String geneRecombineRate) {
		this.geneRecombineRate = geneRecombineRate;
	}
	public String getRisTransportRate() {
		return risTransportRate;
	}
	public void setRisTransportRate(String risTransportRate) {
		this.risTransportRate = risTransportRate;
	}
	public String getRisElement() {
		return risElement;
	}
	public void setRisElement(String risElement) {
		this.risElement = risElement;
	}
	public String getIsTransportRate() {
		return isTransportRate;
	}
	public void setIsTransportRate(String isTransportRate) {
		this.isTransportRate = isTransportRate;
	}
	public String getIsElement() {
		return isElement;
	}
	public void setIsElement(String isElement) {
		this.isElement = isElement;
	}
	public String getGeneTransportRate() {
		return geneTransportRate;
	}
	public void setGeneTransportRate(String geneTransportRate) {
		this.geneTransportRate = geneTransportRate;
	}
	public String getMutateRate() {
		return mutateRate;
	}
	public void setMutateRate(String mutateRate) {
		this.mutateRate = mutateRate;
	}
	public String getTwoPointRecombineRate() {
		return twoPointRecombineRate;
	}
	public void setTwoPointRecombineRate(String twoPointRecombineRate) {
		this.twoPointRecombineRate = twoPointRecombineRate;
	}
	public String getGeneOnePointRecombineRate() {
		return geneOnePointRecombineRate;
	}
	public void setGeneOnePointRecombineRate(String geneOnePointRecombineRate) {
		this.geneOnePointRecombineRate = geneOnePointRecombineRate;
	}
	public int getAvailableModifyingsIndex() {
		return availableModifyingsIndex;
	}
	public void setAvailableModifyings(int availableModifyings) {
		this.availableModifyingsIndex = availableModifyings;
	}
}
ui\alg\Model\ModelForJPanelPopulation.java
package ui.alg.Model;
public class ModelForJPanelPopulation {
	
	String populationSize;
	String selectionRange;
    int populationCreatorIndex;
    int selectionStrategyIndex;
    int availableCalculatorIndex;
    public ModelForJPanelPopulation(String populationSize,String selectionRange,int populationCreator,int selectionStrategy,int availableCalculator){
    	this.availableCalculatorIndex=availableCalculator;
    	this.populationCreatorIndex=populationCreator;
    	this.selectionStrategyIndex=selectionStrategy;
    	this.selectionRange=selectionRange;
    	this.populationSize=populationSize;
    	
    }
    public String getPopulationSize() {
		return populationSize;
	}
	public void setPopulationSize(String populationSize) {
		this.populationSize = populationSize;
	}
	public String getSelectionRange() {
		return selectionRange;
	}
	public void setSelectionRange(String selectionRange) {
		this.selectionRange = selectionRange;
	}
	public int getPopulationCreatorIndex() {
		return populationCreatorIndex;
	}
	public void setPopulationCreatorIndex(int populationCreatorIndex) {
		this.populationCreatorIndex = populationCreatorIndex;
	}
	public int getSelectionStrategyIndex() {
		return selectionStrategyIndex;
	}
	public void setSelectionStrategyIndex(int selectionStrategyIndex) {
		this.selectionStrategyIndex = selectionStrategyIndex;
	}
	public int getAvailableCalculatorIndex() {
		return availableCalculatorIndex;
	}
	public void setAvailableCalculatorIndex(int availableCalculatorIndex) {
		this.availableCalculatorIndex = availableCalculatorIndex;
	}
}
ui\alg\view\HostPanel.java
package ui.alg.view;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.ComboBoxEditor;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.LineBorder;
public class HostPanel extends JPanel {
	
	int count=0;
	public JComboBox jcomboBoxConfiguration;
	public JButton btnNext0=new JButton(),
                   btnSetConfig=new JButton();
	
	public HostPanel(JComboBox jcomboBoxConfiguration) {
		
		setBounds(155, 115, 631, 447);
		setBackground(Color.WHITE);
		setLayout(null);
		setVisible(true);
		JLabel lblNewLabel_28 = new JLabel("\u7B97\u6CD5\u540D\u79F0");
		lblNewLabel_28.setFont(new Font("宋体", Font.PLAIN, 18));
		lblNewLabel_28.setBounds(20, 58, 83, 33);
		add(lblNewLabel_28);
		setBorder(new LineBorder(new Color(0, 0, 0)));
        jcomboBoxConfiguration.setSelectedIndex(-1);
		jcomboBoxConfiguration.setFont(new Font("宋体", Font.PLAIN, 14));
		jcomboBoxConfiguration.setEditable(true);
		jcomboBoxConfiguration.setBackground(Color.WHITE);
		jcomboBoxConfiguration.setBounds(140, 60, 362, 33);
		final ComboBoxEditor editor=jcomboBoxConfiguration.getEditor();
	    jcomboBoxConfiguration.configureEditor(editor,null);
		add(jcomboBoxConfiguration);
	    jcomboBoxConfiguration.setVisible(true);
	   
	    
	    
	
	
	    
	    
	   
        btnSetConfig = new JButton("\u914D\u7F6E\u53C2\u6570");
		btnSetConfig.setBounds(515, 67, 93, 23);
		btnSetConfig.setVisible(true);
		add(btnSetConfig);
		
		
		JLabel lblNewLabel_27 = new JLabel("\u8F93\u5165\u7B97\u6CD5\u540D\u79F0/\u9009\u62E9\u7B97\u6CD5");
		lblNewLabel_27.setFont(new Font("宋体", Font.PLAIN, 18));
		lblNewLabel_27.setBounds(20, 20, 305, 25);
		add(lblNewLabel_27);
		btnNext0 = new JButton("\u4E0B\u4E00\u6B65");
		btnNext0.setBounds(528, 414, 93, 23);
		add(btnNext0);
		
		
		
	    
		
	}
}
ui\alg\view\JPanelForFunction.java
package ui.alg.view;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.border.LineBorder;
public class JPanelForFunction extends JPanel {
	
	public  JTextField txtConstantListSize=new JTextField(),
	                   txtRandomConstantStart=new JTextField();
	public  JButton btnDelFunction = new JButton("\u5220\u9664\u6240\u9009\u51FD\u6570"),
	                btnDelAllFunction = new JButton("\u5220\u9664\u5168\u90E8\u51FD\u6570");
	public 	JComboBox comboBox = new JComboBox(),
	                  JComboBoxOfSelectdFunctions = new JComboBox();
	
	public JPanelForFunction() {
		   
			setBorder(new LineBorder(new Color(0, 0, 0)));
			setBackground(Color.WHITE);
			setBounds(155, 115, 631, 447);
			setVisible(false);
			setLayout(null);
			
			JLabel lblNewLabel_24 = new JLabel("\u586B\u5199\u6240\u9700\u7684\u51FD\u6570\u96C6\u548C\u968F\u673A\u6570");
			lblNewLabel_24.setFont(new Font("宋体", Font.PLAIN, 18));
			lblNewLabel_24.setBounds(20, 20, 216, 25);
			add(lblNewLabel_24);
			
			JLabel lblNewLabel_18 = new JLabel("\u53EF\u4F9B\u9009\u62E9\u7684\u51FD\u6570");
			lblNewLabel_18.setFont(new Font("宋体", Font.PLAIN, 15));
			lblNewLabel_18.setBounds(20, 60, 120, 25);
			add(lblNewLabel_18);
			
		
			comboBox.setBounds(160, 62, 141, 25);
			add(comboBox);
			
			JLabel lblNewLabel_19 = new JLabel("\u5DF2\u9009\u62E9\u7684\u51FD\u6570");
			lblNewLabel_19.setFont(new Font("宋体", Font.PLAIN, 15));
			lblNewLabel_19.setBounds(20, 100, 100, 25);
			add(lblNewLabel_19);
			
			
			
			
			btnDelFunction.setBounds(323, 102, 104, 20);
			add(btnDelFunction);
			btnDelFunction.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					Object selectItem = JComboBoxOfSelectdFunctions
							.getSelectedItem();
					JComboBoxOfSelectdFunctions.removeItem(selectItem);
				}
			});
			
			btnDelAllFunction.setBounds(473, 102, 110, 20);
			add(btnDelAllFunction);
			btnDelAllFunction.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					JComboBoxOfSelectdFunctions.removeAllItems();
				}
			});
			JComboBoxOfSelectdFunctions.setBounds(160, 102, 141, 25);
			add(JComboBoxOfSelectdFunctions);
			
	}
}
ui\alg\view\JPanelForGene.java
package ui.alg.view;
import java.awt.Color;
import java.awt.Font;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.border.LineBorder;
public class JPanelForGene extends JPanel {
	
	public JTextField txtNormalGeneNumber=new JTextField(),
	                   txtNormalHeaderLength=new JTextField(),
                       txtHomeoticGeneNums=new JTextField(),
	                   txtHomeoticHeaderLength=new JTextField(),
                       txtGeneRecombineRate=new JTextField(),
	                   txtRisTransportRate=new JTextField(),
	                   txtofRisElement=new JTextField(),
	                   txtIsTransportRate=new JTextField(),
	                   txtofIsElement=new JTextField(),
	                   txtGeneTransportRate=new JTextField(),
	                   txtMutateRate=new JTextField(),
	                   txtTwoPointRecombineRate=new JTextField(),
	                   txtGeneOnePointRecombineRate=new JTextField();
	public JComboBox JComboBoxOfAvailableModifyings = new JComboBox();
	
	public JPanelForGene() {
		
		setBorder(new LineBorder(new Color(0, 0, 0)));
		setBackground(Color.WHITE);
		setBounds(155, 115, 631, 447);
		setLayout(null);
		setVisible(false);
		JLabel lblNewLabel_6 = new JLabel("\u586B\u5199\u6240\u9700\u7684\u57FA\u56E0\u4FE1\u606F");
		lblNewLabel_6.setFont(new Font("宋体", Font.PLAIN, 18));
		lblNewLabel_6.setBounds(20, 20, 167, 25);
		add(lblNewLabel_6);
		
		JLabel lblNewLabel_7 = new JLabel("\u57FA\u56E0\u4E2A\u6570");
		lblNewLabel_7.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_7.setBounds(20, 60, 100, 25);
		add(lblNewLabel_7);
		
		
		txtNormalGeneNumber.setBounds(160, 60, 120, 25);
		add(txtNormalGeneNumber);
		txtNormalGeneNumber.setColumns(10);
		txtNormalGeneNumber.grabFocus();
		
		txtNormalGeneNumber.addKeyListener(new KeyAdapter(){
		    public void keyPressed(KeyEvent e) {  
		        if(e.getKeyCode() == KeyEvent.VK_ENTER){   
		        	txtNormalHeaderLength.grabFocus();
		        }  
		    }  
		}); 
		JLabel lblNewLabel_8 = new JLabel("\u57FA\u56E0\u5934\u90E8\u5927\u5C0F");
		lblNewLabel_8.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_8.setBounds(340, 60, 100, 25);
		add(lblNewLabel_8);
		
		
		txtNormalHeaderLength.setBounds(485, 62, 120, 25);
		add(txtNormalHeaderLength);
		txtNormalHeaderLength.setColumns(10);
		txtNormalHeaderLength.addKeyListener(new KeyAdapter(){
		    public void keyPressed(KeyEvent e) {  
		        if(e.getKeyCode() == KeyEvent.VK_ENTER){   
		        	txtHomeoticGeneNums.grabFocus();
		        }  
		    }  
		});
		JLabel lblNewLabel_9 = new JLabel("\u540C\u6E90\u67D3\u8272\u4F53\u4E2A\u6570");
		lblNewLabel_9.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_9.setBounds(20, 100, 120, 25);
		add(lblNewLabel_9);
		
		
		txtHomeoticGeneNums.setBounds(160, 100, 120, 25);
		add(txtHomeoticGeneNums);
		txtHomeoticGeneNums.setColumns(10);
		txtHomeoticGeneNums.addKeyListener(new KeyAdapter(){
		    public void keyPressed(KeyEvent e) {  
		        if(e.getKeyCode() == KeyEvent.VK_ENTER){   
		        	txtHomeoticHeaderLength.grabFocus();
		        }  
		    }  
		}); 
		JLabel lblNewLabel_10 = new JLabel("\u540C\u6E90\u67D3\u8272\u4F53\u5934\u90E8\u5927\u5C0F");
		lblNewLabel_10.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_10.setBounds(340, 100, 142, 25);
		add(lblNewLabel_10);
		
		
		txtHomeoticHeaderLength.setBounds(485, 100, 120, 25);
		add(txtHomeoticHeaderLength);
		txtHomeoticHeaderLength.setColumns(10);
		txtHomeoticHeaderLength.addKeyListener(new KeyAdapter(){
		    public void keyPressed(KeyEvent e) {  
		        if(e.getKeyCode() == KeyEvent.VK_ENTER){   
		        	txtGeneRecombineRate.grabFocus();
		        }  
		    }  
		});
		JLabel lblNewLabel_11 = new JLabel("\u57FA\u56E0\u91CD\u7EC4\u6982\u7387");
		lblNewLabel_11.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_11.setBounds(20, 140, 100, 25);
		add(lblNewLabel_11);
		
		
		txtGeneRecombineRate.setBounds(160, 140, 120, 25);
		add(txtGeneRecombineRate);
		txtGeneRecombineRate.setColumns(10);
		txtGeneRecombineRate.addKeyListener(new KeyAdapter(){
		    public void keyPressed(KeyEvent e) {  
		        if(e.getKeyCode() == KeyEvent.VK_ENTER){   
		        	txtGeneOnePointRecombineRate.grabFocus();
		        }  
		    }  
		});
		JLabel lblNewLabel_12 = new JLabel("\u57FA\u56E0\u5355\u70B9\u91CD\u7EC4\u6982\u7387");
		lblNewLabel_12.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_12.setBounds(340, 140, 142, 25);
	    add(lblNewLabel_12);
		
		txtGeneOnePointRecombineRate.setBounds(485, 140, 120, 25);
		add(txtGeneOnePointRecombineRate);
		txtGeneOnePointRecombineRate.setColumns(10);
		txtGeneOnePointRecombineRate.addKeyListener(new KeyAdapter(){
		    public void keyPressed(KeyEvent e) {  
		        if(e.getKeyCode() == KeyEvent.VK_ENTER){   
		        	txtTwoPointRecombineRate.grabFocus();
		        }  
		    }  
		});  
		JLabel lblNewLabel_13 = new JLabel("\u57FA\u56E0\u591A\u70B9\u91CD\u7EC4\u6982\u7387");
		lblNewLabel_13.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_13.setBounds(20, 180, 131, 25);
		add(lblNewLabel_13);
		
		
		txtTwoPointRecombineRate.setBounds(160, 180, 120, 25);
		add(txtTwoPointRecombineRate);
		txtTwoPointRecombineRate.setColumns(10);
		txtTwoPointRecombineRate.addKeyListener(new KeyAdapter(){
		    public void keyPressed(KeyEvent e) {  
		        if(e.getKeyCode() == KeyEvent.VK_ENTER){   
		        	txtMutateRate.grabFocus();
		        }  
		    }  
		}); 
		
		JLabel lblNewLabel_30 = new JLabel("\u57FA\u56E0\u7A81\u53D8\u6982\u7387");
		lblNewLabel_30.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_30.setBounds(340, 180, 100, 25);
		add(lblNewLabel_30);
		
		
		txtMutateRate.setBounds(485, 180, 120, 25);
		add(txtMutateRate);
		txtMutateRate.setColumns(10);
		txtMutateRate.addKeyListener(new KeyAdapter(){
		    public void keyPressed(KeyEvent e) {  
		        if(e.getKeyCode() == KeyEvent.VK_ENTER){   
		        	txtGeneTransportRate.grabFocus();
		        }  
		    }  
		}); 
		
		JLabel lblNewLabel_31 = new JLabel("\u57FA\u56E0\u8F6C\u5EA7\u6982\u7387");
		lblNewLabel_31.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_31.setBounds(20, 220, 100, 25);
		add(lblNewLabel_31);
		
	    txtGeneTransportRate.setBounds(160, 220, 120, 25);
		add(txtGeneTransportRate);
		txtGeneTransportRate.setColumns(10);
		txtGeneTransportRate.addKeyListener(new KeyAdapter(){
		    public void keyPressed(KeyEvent e) {  
		        if(e.getKeyCode() == KeyEvent.VK_ENTER){   
		        	txtofIsElement.grabFocus();
		        }  
		    }  
		}); 
		
		JComboBoxOfAvailableModifyings.setBounds(485, 220, 120, 25);
		add(JComboBoxOfAvailableModifyings);
		
		JLabel lblNewLabel_32 = new JLabel("\u57FA\u56E0\u9009\u62E9\u53D8\u5F02\u7B56\u7565");
		lblNewLabel_32.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_32.setBounds(340, 220, 120, 25);
		add(lblNewLabel_32);
		
		JLabel lblNewLabel_14 = new JLabel("IS\u957F\u5EA6");
		lblNewLabel_14.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_14.setBounds(20, 260, 100, 25);
		add(lblNewLabel_14);
		
		
		txtofIsElement.setBounds(160, 260, 120, 25);
		add(txtofIsElement);
		txtofIsElement.setColumns(10);
		txtofIsElement.addKeyListener(new KeyAdapter(){
		    public void keyPressed(KeyEvent e) {  
		        if(e.getKeyCode() == KeyEvent.VK_ENTER){   
		        	txtIsTransportRate.grabFocus();
		        }  
		    }  
		});  
		JLabel lblNewLabel_15 = new JLabel("IS\u8F6C\u5EA7\u7387");
		lblNewLabel_15.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_15.setBounds(340, 260, 100, 25);
		add(lblNewLabel_15);
		
		
		txtIsTransportRate.setBounds(485, 260, 120, 25);
		add(txtIsTransportRate);
		txtIsTransportRate.setColumns(10);
		txtIsTransportRate.addKeyListener(new KeyAdapter(){
		    public void keyPressed(KeyEvent e) {  
		        if(e.getKeyCode() == KeyEvent.VK_ENTER){   
		        	txtofRisElement.grabFocus();
		        }  
		    }  
		});  
		
		txtofRisElement.setBounds(160, 300, 120, 25);
		add(txtofRisElement);
		txtofRisElement.setColumns(10);
		txtofRisElement.addKeyListener(new KeyAdapter(){
		    public void keyPressed(KeyEvent e) {  
		        if(e.getKeyCode() == KeyEvent.VK_ENTER){   
		        	txtRisTransportRate.grabFocus();
		        }  
		    }  
		});
		JLabel lblNewLabel_16 = new JLabel("RIS\u957F\u5EA6");
		lblNewLabel_16.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_16.setBounds(20, 300, 100, 25);
		add(lblNewLabel_16);
		
		JLabel lblNewLabel_17 = new JLabel("RIS\u8F6C\u5EA7\u7387");
		lblNewLabel_17.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_17.setBounds(340, 300, 100, 25);
		add(lblNewLabel_17);
		
		
		txtRisTransportRate.setBounds(485, 300, 120, 25);
		add(txtRisTransportRate);
		txtRisTransportRate.setColumns(10);
        /*btnForward3.addActionListener(new ActionListener(){
              public void actionPerformed(ActionEvent e) {
				TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node2));
				tree_1.setSelectionPath(visiblePath);
				HostPane.setVisible(false);
        		panel_1.setVisible(false);
        		panel_2.setVisible(true);
        		panel_3.setVisible(false);
        		panel_4.setVisible(false);
				
			}
			});*/
		//panel_0.add(panel_3);
	}
}
ui\alg\view\JPanelForPopulation.java
package ui.alg.view;
import java.awt.Color;
import java.awt.Font;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.border.LineBorder;
public class JPanelForPopulation extends JPanel {
	
    public JTextField 
	txtPopulationSize = new JTextField();
    public JTextField txtSelectionRange = new JTextField();
	public JComboBox JcomboBoxOfPopulationCreator = new JComboBox(),
	          JComboBoxofSelectionStrategy = new JComboBox();
	public JComboBox JComboBoxAvailableCalculator = new JComboBox();
	
	
	public JPanelForPopulation() {
		
		setBorder(new LineBorder(new Color(0, 0, 0)));
		setBounds(155, 115, 631, 447);
		setForeground(Color.DARK_GRAY);
		setBackground(Color.WHITE);
		setLayout(null);
		setVisible(false);
		
		JLabel lblNewLabel = new JLabel("\u586B\u5199\u6240\u9700\u7684\u79CD\u7FA4\u4FE1\u606F");
		lblNewLabel.setForeground(Color.BLACK);
		lblNewLabel.setFont(new Font("宋体", Font.PLAIN, 20));
		lblNewLabel.setBounds(20, 20, 189, 25);
		add(lblNewLabel);
		
		JLabel lblNewLabel_1 = new JLabel("\u79CD\u7FA4\u521D\u59CB\u5316\u5927\u5C0F");
		lblNewLabel_1.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_1.setBounds(20, 60, 120, 25);
		add(lblNewLabel_1);
		
		
		txtPopulationSize.setBounds(160, 60, 120, 25);
		add(txtPopulationSize);
		txtPopulationSize.setColumns(10);
		txtPopulationSize.grabFocus();
		
		
		JLabel lblNewLabel_3 = new JLabel("\u79CD\u7FA4\u521D\u59CB\u5316\u65B9\u5F0F");
		lblNewLabel_3.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_3.setBounds(340, 60, 134, 25);
		add(lblNewLabel_3);
		
		
		JcomboBoxOfPopulationCreator.setBounds(485, 60, 120, 21);
		add(JcomboBoxOfPopulationCreator);
		
		JLabel  lblNewLabel_5= new JLabel("\u9009\u62E9\u4E2A\u4F53\u7684\u8303\u56F4");
		lblNewLabel_5.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_5.setBounds(340, 100, 120, 25);
		add(lblNewLabel_5);
		
		
		txtSelectionRange.setBounds(485, 100, 120, 25);
		add(txtSelectionRange);
		txtSelectionRange.setColumns(10);
		
		JLabel lblNewLabel_4 = new JLabel("\u9009\u62E9\u4E2A\u4F53\u7684\u7B56\u7565");
		lblNewLabel_4.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_4.setBounds(20, 100, 120, 25);
		add(lblNewLabel_4);
		
		
		JComboBoxofSelectionStrategy.setBounds(160, 100, 120, 21);
		add(JComboBoxofSelectionStrategy);
		
		JLabel lblNewLabel_33 = new JLabel("\u9002\u5E94\u503C\u8BA1\u7B97\u65B9\u5F0F");
		lblNewLabel_33.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_33.setBounds(20, 140, 120, 25);
	    add(lblNewLabel_33);
		
		
		JComboBoxAvailableCalculator.setBounds(160, 140, 120, 21);
		add(JComboBoxAvailableCalculator);
		/*btnNext2.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent e) {
				TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node3));
				tree_1.setSelectionPath(visiblePath);
				
				
				HostPane.setVisible(false);
        		panel_1.setVisible(false);
        		panel_2.setVisible(true);
        		panel_3.setVisible(false);
        		panel_4.setVisible(false);
				
			}
			
		});*/
	}
}
ui\alg\view\JPanelForStopSetting.java
package ui.alg.view;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.SystemColor;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.border.LineBorder;
public class JPanelForStopSetting extends JPanel {
	
	public JTextField txtMaxGeneration=new JTextField(),
	                  txtAccuracy=new JTextField();
	
	
	
	public JPanelForStopSetting() {
		   
		    setBounds(155, 115, 631, 447);
		    setVisible(false);
		    setBorder(new LineBorder(new Color(0, 0, 0)));
		    setBackground(Color.WHITE);
		    setLayout(null);
		    
		  
		    
		    JPanel panel = new JPanel();
		    panel.setBounds(0, 561, 813, 87);
		    
		    panel.setLayout(null);
		    
		    JLabel lblNewLabel_38 = new JLabel("-----------1.0\u7248\u672C\uFF08c\uFF09Miscrosoft Cooperation------------");
		    lblNewLabel_38.setBounds(162, 35, 463, 28);
		    lblNewLabel_38.setFont(new Font("宋体", Font.PLAIN, 13));
		    lblNewLabel_38.setForeground(Color.RED);
		    panel.add(lblNewLabel_38);
		    JLabel lblNewLabel_40 = new JLabel("\u586B\u5199\u6240\u9700\u7684\u7B97\u6CD5\u7EC8\u6B62\u6761\u4EF6");
		    lblNewLabel_40.setFont(new Font("宋体", Font.PLAIN, 18));
		    lblNewLabel_40.setBounds(20, 20, 208, 25);
		    add(lblNewLabel_40);
		    
		    JLabel lblNewLabel_41 = new JLabel("\u6F14\u5316\u4EE3\u6570");
		    lblNewLabel_41.setFont(new Font("宋体", Font.PLAIN, 17));
		    lblNewLabel_41.setBounds(20, 60, 120, 25);
		    add(lblNewLabel_41);
		    
		    txtMaxGeneration.setBounds(160, 60, 160, 25);
		    add(txtMaxGeneration);
		    txtMaxGeneration.setColumns(10);
		    
		    JLabel lblNewLabel_42 = new JLabel("\u7B97\u6CD5\u7ED3\u679C\u7684\u7CBE\u5EA6");
		    lblNewLabel_42.setFont(new Font("宋体", Font.PLAIN, 17));
		    lblNewLabel_42.setBounds(20, 120, 120, 25);
		    add(lblNewLabel_42);
		    
		    txtAccuracy = new JTextField();
		    txtAccuracy.setBounds(160, 120, 160, 25);
		    add(txtAccuracy);
		    txtAccuracy.setColumns(10);
		
		}
	  
}
ui\input\controller\DownLoadInterfaceController.java
package ui.input.controller;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;
import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import javax.tools.JavaCompiler.CompilationTask;
public class DownLoadInterfaceController {
	   private static String fileName;
	   private static String defaultFileSavePath=".\\bin\\domain\\service\\input\\";
	   private static File file;
	   private static File saveDir;
	   static StringBuffer buffer;
	   public static int btnDownLoadController(ModelForDownLoadInterface downLoadInterface) throws IOException{
		   file=downLoadInterface.getFile();
		   saveDir=new File(defaultFileSavePath);
		   buffer=ReadFile(file,saveDir);
		   return WriteFile(buffer,file.getName());
	   }
	
	private static StringBuffer ReadFile(File file, File saveDir) {
		try{
		       
		       BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(file),"GBK"));
		       String data=null;
		       StringBuffer buffer=new StringBuffer();
		       while((data=reader.readLine())!=null){
		    	
		    	   buffer.append(data+"\n");
		       }
		        reader.close();
		        return buffer;
		 }catch(IOException e){
			     throw new RuntimeException();
		}
    }
	private static int WriteFile(StringBuffer buffer, String name) throws IOException {
		 //检查指定路径是否存在
		 File newInterface=new File(saveDir.getName()+file.getName());
		 
		 if(!saveDir.exists()&&!saveDir.isDirectory()){//检查文件夹是否存在，不存在就生成
			 saveDir.mkdirs();
			 
		 }
		BufferedWriter writer = null;
		try {
			writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(newInterface),"GBK"));
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	     writer.write(buffer.toString());
		 writer.flush();
	     writer.close();
	     return 0;
	}
}
ui\input\controller\FooterPanelController.java
package ui.input.controller;
import java.awt.CardLayout;
import java.io.IOException;
import java.util.List;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import ui.alg.Model.ModelForJPanelConfig;
import ui.alg.Model.ModelForJPanelFunction;
import ui.alg.Model.ModelForJPanelGEne;
import ui.alg.Model.ModelForJPanelPopulation;
import ui.alg.view.HostPanel;
import ui.alg.view.JPanelForFunction;
import ui.alg.view.JPanelForGene;
import ui.alg.view.JPanelForStopSetting;
import ui.alg.view.JPanelForPopulation;
import ui.input.model.ModelForJPanelInputPath;
import ui.input.view.JPanelForFooter;
import domain.core.outputmodel.GepConfiguration;
import domain.iservice.IgepAlgService;
import domain.service.alg.configuration.GepAlgService;
import domain.service.input.DefaultGepInput;
import domain.service.input.IgepInput;
import jxl.read.biff.BiffException;
import exception.Duplicated;
public class FooterPanelController {
	
    
	 public static int btnNextController(DefaultMutableTreeNode[] node,JTree tree_1,JPanelForFooter footPanel,JPanel panel_0,CardLayout card,int count) {
		footPanel.btnBefore.setEnabled(true);
  		card.next(panel_0);
  		switch(count){
  		  case 0:{
  			TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node[1]));
    		tree_1.setSelectionPath(visiblePath);
    		System.out.println("第-个Node"+node[1].toString());
    		break; 
  		  }
  		  case 1:{
  			TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node[2]));
    		tree_1.setSelectionPath(visiblePath);
    		System.out.println("第二个Node"+node[2].toString());
    		break;
  		  }
  		  case 2:{
  			TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node[3]));
    		tree_1.setSelectionPath(visiblePath);
    		System.out.println("第三个Node"+node[3].toString());
    		break;
  		  }
  		  case 3:{
  			TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node[4]));
    		tree_1.setSelectionPath(visiblePath);
    	    System.out.println("第四个Node"+node[4].toString());
    		break;
  		  }
  		 default:{
  			break;
  			
  		  }
  		}
  		if(count==3){
  			footPanel.btnNext.setEnabled(false);
  			footPanel.btnRun.setEnabled(true);
  		}
  		if(count==4){
  			return count;
  		}
  		count++;
  		System.out.println(count);
  		return count;
	}
    public static int btnBeforeController(DefaultMutableTreeNode node[],JTree tree_1,JButton  btnNext,JButton btnBefore,JPanel panel_0,CardLayout card,int count) {
    	count--;
  		if(count==0){
  			btnBefore.setEnabled(false);
  		}
  			btnNext.setEnabled(true);
  		
  		System.out.println(count);
  		switch(count){
  		  case 0:{
  			TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node[0]));
    		tree_1.setSelectionPath(visiblePath);
    	    System.out.println("第0个Node"+node[0].toString());
    		break;
  		  }
  		  case 1:{
  			TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node[1]));
    		tree_1.setSelectionPath(visiblePath);
    		System.out.println("第1个Node"+node[1].toString());
    		break;
  		  }
  		  case 2:{
  			TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node[2]));
    		tree_1.setSelectionPath(visiblePath);
    		System.out.println("第2个Node"+node[2].toString());
    		break;
  		  }
  		  case 3:{
  			TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node[3]));
    		tree_1.setSelectionPath(visiblePath);
    		System.out.println("第3个Node"+node[3].toString());
    		break;
  		  }
  		 default:{
  			TreePath visiblePath=new TreePath(((DefaultTreeModel)tree_1.getModel()).getPathToRoot(node[3]));
    		tree_1.setSelectionPath(visiblePath);
    		System.out.println("第3个Node"+node[3].toString());
    		break;
  		  }
  		}
  		card.previous(panel_0);
  		return count;
		
	}
	public static boolean btnRunController(ModelForJPanelConfig configuration,ModelForJPanelInputPath inputPath,
	   ModelForJPanelPopulation population,ModelForJPanelGEne gene,ModelForJPanelFunction function,
	   GepConfiguration myParameter,IgepAlgService myGepService,GepConfiguration myConfigurationFromDB,int flag){
		String risElement = gene.getRisElement();
		String strRisElement = "";
		for (int i = 0; i < risElement.length(); i++) {
				if (i != 0) {
					if (risElement.charAt(i) != ','
							&& (risElement.substring(0, i).indexOf(
									risElement.charAt(i)) < 0)) {
						strRisElement = strRisElement
								+ risElement.charAt(i);
					}
				} else {
					if (risElement.charAt(i) != ',') {
						strRisElement = strRisElement
								+ risElement.charAt(i);
					}
				}
			}
		String isElement = gene.getIsElement();
		String strIsElement = "";
		for (int i = 0; i < isElement.length(); i++) {
				if (i != 0) {
					if (isElement.charAt(i) != ','
							&& (isElement.substring(0, i).indexOf(
									isElement.charAt(i)) < 0)) {
						strIsElement = strIsElement + isElement.charAt(i);
					}
				} else {
					if (isElement.charAt(i) != ',') {
						strIsElement = strIsElement + isElement.charAt(i);
					}
				}
			}
		
		myParameter.setInputFile(inputPath.getInputPath());
		myParameter.setName(configuration.getConfig());
		myParameter.setAccuray(inputPath.getAccuracy());
		myParameter.setNormalGeneNumber(gene.getNormalGeneNumber());
		myParameter.setGeneRecombineRate(gene.getGeneRecombineRate());
		myParameter.setGeneTransportRate(gene.getGeneTransportRate());
		myParameter.setNormalHeaderLength(gene.getNormalHeaderLength());
		myParameter.setIsTransportRate(gene.getIsTransportRate());
		myParameter.setMaxGeneration(inputPath.getMaxgeneration());
		myParameter.setOnePointRecombineRate(gene.getGeneOnePointRecombineRate());
		myParameter.setPopulationSize(population.getPopulationSize());
		myParameter.setRisTransportRate(gene.getRisTransportRate());
		myParameter.setSelectionRange(population.getSelectionRange());
		myParameter.setTwoPointRecombineRate(gene.getTwoPointRecombineRate());
		myParameter.setIsElement(gene.getIsElement());
        myParameter.setRisElement(gene.getRisElement());
		myParameter.setHomeoticGeneNumber(gene.getHomeoticGeneNums());
	    myParameter.setHomeoticHeaderLength(gene.getHomeoticHeaderLength());
		myParameter.setFunctionList(function.getFunctions().toString());
		myParameter.setMutateRate(gene.getMutateRate());
				
	    try {
			myParameter.setSelector(myGepService.getAvailableSelector().get(population.getSelectionStrategyIndex()).getClass().getName());
			myParameter.setCalculator(myGepService.getAvailableCalculator().get(population.getAvailableCalculatorIndex()).getClass().getName());
			myParameter.setCreator(myGepService.getAvailableCreator().get(population.getPopulationCreatorIndex()).getClass().getName());
			myParameter.setModify(myGepService.getAvailableModifyings().get(gene.getAvailableModifyingsIndex()).getClass().getName());
			
		} catch (ClassNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (InstantiationException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IllegalAccessException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
			
			
		    
		try {
			myGepService.setParameters(myParameter);
		} catch (BiffException e3) {
			// TODO Auto-generated catch block
			e3.printStackTrace();
		} catch (InstantiationException e3) {
			// TODO Auto-generated catch block
			e3.printStackTrace();
		} catch (IllegalAccessException e3) {
			// TODO Auto-generated catch block
			e3.printStackTrace();
		} catch (ClassNotFoundException e3) {
			// TODO Auto-generated catch block
			e3.printStackTrace();
		} catch (IOException e3) {
			// TODO Auto-generated catch block
			e3.printStackTrace();
		}
		
		
		
       myGepService.run();
       
       
       
       if (flag == -1) {
				if (myParameter.equals(myConfigurationFromDB) == false) {
					return false;
					}
				else{
					
					return true;
				}
		} 
		else {
				try {
					myGepService.saveArgumentsToDb(myParameter);
				} catch (Duplicated e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				return true;
				
		}
		
		
	}
    
}
ui\input\controller\ModelForDownLoadInterface.java
package ui.input.controller;
import java.io.File;
public class ModelForDownLoadInterface {
	   String fileName;
	   String interfacePath;
	   File file;
	   File saveDir;
	   
	   public String getFileName() {
			return fileName;
		}
		public void setFileName(String fileName) {
			this.fileName = fileName;
		}
		
		public String getInterfacePath() {
				return interfacePath;
		}
		public void setInterfacePath(String interfacePath) {
				this.interfacePath = interfacePath;
		}
		
		public void setFile(File file) {
				this.file = file;
		}
		public File getFile() {
			   return file;
		}
		 public File getSaveDir() {
				return saveDir;
		}
		public void setDir(File dir) {
				this.saveDir = dir;
	    }
		
		public ModelForDownLoadInterface(File file,File dir,String fileName, String interfacePath) {
			super();
			this.file=file;
			this.saveDir=dir;
			this.fileName = fileName;
			this.interfacePath=interfacePath;
		}
		
}
ui\input\controller\SaveConfigPanelController.java
package ui.input.controller;
import javax.swing.JPanel;
import ui.input.view.JPanelForJTree;
import ui.output.view.JPanelForOutput;
import ui.input.view.JPanelForSaveConfig;
import domain.core.outputmodel.GepConfiguration;
import domain.iservice.IgepAlgService;
import exception.Duplicated;
public class SaveConfigPanelController {
	
   public static void btnSaveController(IgepAlgService myGepService,GepConfiguration myParameter,ui.output.view.JPanelForOutput outputPanel,JPanelForSaveConfig savePanel,JPanelForJTree treePanel,JPanel panel_0){
	    
		outputPanel.setVisible(true);
		savePanel.setVisible(false);
		treePanel.setVisible(false);
   }
}
ui\input\controller\TreePanelController.java
package ui.input.controller;
import java.awt.event.MouseEvent;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.JTree;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
public class TreePanelController {
   public static int  treeMouseListener(MouseEvent e,JPanel[] panels,JButton btnBefore,JButton btnNext,int count){
	   JTree tree = (JTree) e.getSource();
       int selRow = tree.getRowForLocation(e.getX(), e.getY());
      TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());
      if (selRow != -1)
      {
          if (e.getClickCount() == 1)
          {
          	TreeNode node = (TreeNode) selPath.getLastPathComponent();
          	if(node.toString()=="算法系统"){
          		panels[0].setVisible(true);
          		panels[1].setVisible(false);
          		panels[2].setVisible(false);
          		panels[3].setVisible(false);
          		panels[4].setVisible(false);
          		panels[5].setVisible(false);
          		panels[6].setVisible(false);
          		panels[7].setVisible(false);
          		panels[8].setVisible(true);
          		panels[9].setVisible(true);
          		btnBefore.setEnabled(false);
          		btnNext.setEnabled(true);
          		count=0;
          	}
          	if(node.toString()=="算法名称"){
          		panels[0].setVisible(true);
          		panels[1].setVisible(false);
          		panels[2].setVisible(false);
          		panels[3].setVisible(false);
          		panels[4].setVisible(false);
          		panels[5].setVisible(false);
          		panels[6].setVisible(false);
          		panels[7].setVisible(false);
          		panels[8].setVisible(true);
          		panels[9].setVisible(true);
          		btnBefore.setEnabled(true);
          		btnNext.setEnabled(true);
          		count=0;
          	}
          	if(node.toString()=="算法终止条件"){
          		panels[0].setVisible(false);
          		panels[1].setVisible(true);
          		panels[2].setVisible(false);
          		panels[3].setVisible(false);
          		panels[4].setVisible(false);
          		panels[5].setVisible(false);
          		panels[6].setVisible(false);
          		panels[7].setVisible(false);
          		panels[8].setVisible(true);
          		panels[9].setVisible(true);
          		btnBefore.setEnabled(true);
          		btnNext.setEnabled(true);
          		count=1;
          	}
          	if(node.toString()=="种群信息"){
          		panels[0].setVisible(false);
          		panels[1].setVisible(false);
          		panels[2].setVisible(true);
          		panels[3].setVisible(false);
          		panels[4].setVisible(false);
          		panels[5].setVisible(false);
          		panels[6].setVisible(false);
          		panels[7].setVisible(false);
          		panels[8].setVisible(true);
          		panels[9].setVisible(true);
          		btnBefore.setEnabled(true);
          		btnNext.setEnabled(true);
          		count=2;
          	}
          	if(node.toString()=="基因信息"){
          		panels[0].setVisible(false);
          		panels[1].setVisible(false);
          		panels[2].setVisible(false);
          		panels[3].setVisible(true);
          		panels[4].setVisible(false);
          		panels[5].setVisible(false);
          		panels[6].setVisible(false);
          		panels[7].setVisible(false);
          		panels[8].setVisible(true);
          		panels[9].setVisible(true);
          		btnBefore.setEnabled(true);
          		btnNext.setEnabled(true);
          		count=3;
          	}
          	if(node.toString()=="所需函数和随机数"){
          		panels[0].setVisible(false);
          		panels[1].setVisible(false);
          		panels[2].setVisible(false);
          		panels[3].setVisible(false);
          		panels[4].setVisible(true);
          		panels[5].setVisible(false);
          		panels[6].setVisible(false);
          		panels[7].setVisible(false);
          		panels[8].setVisible(true);
          		panels[9].setVisible(true);
          		btnBefore.setEnabled(true);
          		btnNext.setEnabled(false);
          		count=4;
          	}
          	if(node.toString()=="输入系统"){
          		panels[0].setVisible(false);
          		panels[1].setVisible(false);
          		panels[2].setVisible(false);
          		panels[3].setVisible(false);
          		panels[4].setVisible(false);
          		panels[5].setVisible(true);
          		panels[6].setVisible(false);
          		panels[7].setVisible(false);
          		panels[8].setVisible(false);
          		panels[9].setVisible(false);
          	} 
          	if(node.toString()=="上传/下载接口"){
          		panels[0].setVisible(false);
          		panels[1].setVisible(false);
          		panels[2].setVisible(false);
          		panels[3].setVisible(false);
          		panels[4].setVisible(false);
          		panels[5].setVisible(true);
          		panels[6].setVisible(false);
          		panels[7].setVisible(false);
          		panels[8].setVisible(false);
          		panels[9].setVisible(false);
          	} 
          	if(node.toString()=="输入路径"){
          		panels[0].setVisible(false);
          		panels[1].setVisible(false);
          		panels[2].setVisible(false);
          		panels[3].setVisible(false);
          		panels[4].setVisible(false);
          		panels[5].setVisible(false);
          		panels[6].setVisible(true);
          		panels[7].setVisible(false);
          		panels[8].setVisible(false);
          		panels[9].setVisible(false);
          	}
          	if(node.toString()=="输出系统"){
          		panels[0].setVisible(false);
          		panels[1].setVisible(false);
          		panels[2].setVisible(false);
          		panels[3].setVisible(false);
          		panels[4].setVisible(false);
          		panels[5].setVisible(false);
          		panels[6].setVisible(false);
          		panels[8].setVisible(false);
          	    panels[9].setVisible(false);
          		panels[7].setVisible(true);
          		panels[10].setVisible(false);
          	}  
          	if(node.toString()=="输出结果"){
          		panels[0].setVisible(false);
          		panels[1].setVisible(false);
          		panels[2].setVisible(false);
          		panels[3].setVisible(false);
          		panels[4].setVisible(false);
          		panels[5].setVisible(false);
          		panels[6].setVisible(false);
          		panels[8].setVisible(false);
          	    panels[9].setVisible(false);
          		panels[7].setVisible(true);
          		panels[10].setVisible(false);
          	}  
          	
          } 
      }
	return count;
   }
}
ui\input\controller\UploadInterfaceController.java
package ui.input.controller;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;
import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import javax.tools.JavaCompiler.CompilationTask;
import jxl.read.biff.BiffException;
import domain.core.outputmodel.GepConfiguration;
import domain.iservice.IgepAlgService;
import ui.alg.view.HostPanel;
import ui.alg.view.JPanelForFunction;
import ui.alg.view.JPanelForGene;
import ui.alg.view.JPanelForStopSetting;
import ui.alg.view.JPanelForPopulation;
import ui.input.model.ModelForUploadInterface;
public class UploadInterfaceController {
   private static String fileName;
   private static boolean available;
   private static String defaultFileSavePath=".\\bin\\domain\\service\\input\\";
   private static File file;
   private static File saveDir;
   static String packagePath;
   static StringBuffer buffer;
   public static int btnUploadController(ModelForUploadInterface uploadInterface) throws IOException{
	   file=uploadInterface.getFile();
	   saveDir=new File(defaultFileSavePath);
	   try {
		buffer=ReadFile(file,saveDir);
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	   return WriteFile(buffer,file.getName());
   }
   public static StringBuffer ReadFile(File file,File saveDir)throws IOException{
		
	     try{
	       
	       BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(file),"GBK"));
	       String data=null;
	       StringBuffer buffer=new StringBuffer();
	       
	     
	    	 buffer.append("package domain.service.input;"+"\n"); 
	    	//会报错
	       
	       
	       int j=1;//当第一次读时替换package
	       
	       while((data=reader.readLine())!=null){
	    	 if(j!=1&&j!=2){
	    	   buffer.append(data+"\n");
	    	   fileName=file.getName().substring(0,file.getName().indexOf(".java"));//得到类名
	    	   char[] dataToChar =new char[data.length()];
	    	   String dataStr=new String();
	    	   for(int i=0;i<data.length();i++ ){
	    		   if(data.charAt(i)!=' '&&data.charAt(i)!='	'){
	    			   dataToChar[i]=data.charAt(i);
	    			   dataStr=dataStr+dataToChar[i];
	    		   }
	    		   
	    	   }
	    	 
	    	   
	    	 }
	    	 j++;
	       }
	        reader.close();
	        return buffer;
	       }catch(IOException e){
		     throw new RuntimeException();
	      }
	  }
	   
	   
	   
	   
	  public static <T> int WriteFile(StringBuffer buffer,String fileName) throws IOException{
		  
		  
		  
		
		  
		 //检查指定路径是否存在
		 File newInterface=new File(defaultFileSavePath+file.getName());
		 
		 if(!saveDir.exists()&&!saveDir.isDirectory()){//检查文件夹是否存在，不存在就生成
			 newInterface.mkdirs();
			 
		 }
		 File[] filesBeforeUpload=saveDir.listFiles();
		 
		 List<File> filesListBeforeUpload=new ArrayList<File>();
		 for(int i = 0; i< filesBeforeUpload.length;i++){
			   filesListBeforeUpload.add(filesBeforeUpload[i]);
		       if(file.getName().equals(filesBeforeUpload[i].getName())){
		    	  
		    	 //相同文件名的文件已存在
		    	   
					 System.out.println("文件已存在");
					 newInterface.delete();
				   return -1;//文件已存在
		       }
		   }
			   
         
	     
		 
		
		 
	     BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(newInterface),"GBK"));
	     writer.write(buffer.toString());
		 writer.flush();
	     writer.close();
	     //生成。class文件
	     JavaCompiler complier=ToolProvider.getSystemJavaCompiler();
	     //通过TOOlProvider类的静态方法getSystemJavaCompiler来得到一个JAvaCompiler接口的实例,不能有效的控制输入输出
	     StandardJavaFileManager fileMgr=complier.getStandardFileManager(null, null, null);
	     //
	     Iterable units=fileMgr.getJavaFileObjects(defaultFileSavePath+file.getName());
	     System.out.print(defaultFileSavePath+file.getName());
	     CompilationTask t=complier.getTask(null,fileMgr,null,null,null,units);
	     //writer out：用于输出错误的流，默认为System。err
	     //javaFileManager fileManager：标准的文件管理
	     //DiagnosticListener diagnosticListener:编译器的默认行为
	     //iterable option:编译器选项
	     //iterable class:参与编译的文件
	     //iterable compiliationUnis不能为null,保存编译的java文件
	     t.call();//编译源程序
	     fileMgr.close();
	    
		
		try {
			fileName=file.getName().substring(0,file.getName().indexOf(".java"));//得到类名
			String filePathString=defaultFileSavePath;
			
			File classfiles=new File(filePathString);
			System.out.println(filePathString);
			System.out.println(classfiles.toString());
			//---检查实现的接口
			List<T> resultList=new ArrayList<T>(classfiles.list().length);
			Class<?> myClass=Class.forName("domain.service.input."+fileName);
			for(String string:classfiles.list()){
				
				available=myClass.isInstance(string);
			}
			if(available==false){
				File[] filesAfterUpload=saveDir.listFiles();
				
				for(int i = 0; i< filesAfterUpload.length;i++){
					if(!filesListBeforeUpload.contains(filesAfterUpload[i])){
						filesAfterUpload[i].delete();
					 }
				}
				
				return -2;//没有实现接口
				
			}
			int i=0;
			//检查实现构造函数
			Constructor<?>[] constructorArray=myClass.getConstructors();
			for(Constructor<?> constructor:constructorArray){
				if(constructor.getParameterTypes().length==0){
					break;
				}
				else{
					i++;
				}
				
			}
			if(i==constructorArray.length){
				File[] filesAfterUpload=saveDir.listFiles();
				for(int j = 0; j< filesAfterUpload.length;i++){
					if(!filesListBeforeUpload.contains(filesAfterUpload[j])){
						filesAfterUpload[j].delete();
					 }
				}
				return -3;//没有默认构造函数
				
			}
		 } catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}  
		
		
	    
	     return 0;//可以上传
	   }
}
	  
ui\input\model\ModelForJPanelInputPath.java
package ui.input.model;
public class ModelForJPanelInputPath {
    String inputPath;
    String maxGeneration;
    String accuracy;
    public ModelForJPanelInputPath(String inputPath,String maxGeneration,String accuracy){
    	this.inputPath=inputPath;
    	this.maxGeneration=maxGeneration;
    	this.accuracy=accuracy;
    	
    }
    public void setInputPath(String inputPath){
    	this.inputPath=inputPath;
    }
    public void setMaxGeneration(String maxGeneration){
    	this.maxGeneration=maxGeneration;
    }
    public void setAccuracy(String accuracy){
    	this.accuracy=accuracy;
    }
    public String getInputPath(){
        return inputPath;
    }
    public String getMaxgeneration(){
    	return maxGeneration;
    }
    public String getAccuracy(){
    	return accuracy;
    }
}
ui\input\model\ModelForUploadInterface.java
package ui.input.model;
import java.io.File;
public class ModelForUploadInterface {
   
   String fileName;
   String interfacePath;
   File file;
   File dir;
   
   public String getFileName() {
		return fileName;
	}
	public void setFileName(String fileName) {
		this.fileName = fileName;
	}
	
	public String getInterfacePath() {
			return interfacePath;
	}
	public void setInterfacePath(String interfacePath) {
			this.interfacePath = interfacePath;
	}
	public File getFile() {
			return file;
    }
	public void setFile(File file) {
			this.file = file;
	}
	 public File getDir() {
			return dir;
	}
	public void setDir(File dir) {
			this.dir = dir;
    }
	
	public ModelForUploadInterface(File file,File dir,String fileName, String interfacePath) {
		super();
		this.file=file;
		this.dir=dir;
		this.fileName = fileName;
		this.interfacePath=interfacePath;
	}
	
}
ui\input\view\JPanelForFooter.java
package ui.input.view;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.border.LineBorder;
public class JPanelForFooter extends JPanel {
	
	public JButton btnNext = new JButton("下一步 >");
    public JButton btnBefore = new JButton("< 上一步");
    public JButton btnRun = new JButton("\u6267\u884C\u7B97\u6CD5");
    
	public JPanelForFooter() {
		
	      setBorder(new LineBorder(new Color(0, 0, 0)));
	      setBackground(Color.WHITE);
	      setBounds(160, 523, 669, 39);
	      setLayout(null);
	      	      
	      btnNext.setBounds(523, 10, 93, 23);
	      add(btnNext);
	      
	      
	      btnBefore.setEnabled(false);
	      
	      btnBefore.setBounds(105, 10, 93, 23);
	      add(btnBefore);
	      
	      
	      btnRun.setBounds(312, 10, 93, 23);
	      add(btnRun);
	}
}
ui\input\view\JPanelForInputFile.java
package ui.input.view;
import java.awt.Color;
import java.awt.Font;
import java.awt.SystemColor;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.IOException;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import ui.alg.view.JPanelForStopSetting;
import ui.input.controller.ModelForDownLoadInterface;
import ui.input.controller.UploadInterfaceController;
import ui.input.model.ModelForUploadInterface;
import ui.input.view.JPanelForUploadInterface.OpenHandler;
import javax.swing.JComboBox;
import javax.swing.border.LineBorder;
public class JPanelForInputFile extends JPanel {
	public JTextField txtInputPath = new JTextField();
	public JButton btnInputBrowse = new JButton("\u6D4F\u89C8");
	public JPanelForInputFile() {
		setBorder(new LineBorder(new Color(0, 0, 0)));
		setBounds(155, 115, 631, 532);
		setBackground(Color.WHITE);
		setLayout(null);
		setVisible(true);
		
		 JLabel lblNewLabel_26 = new JLabel("\u586B\u5199\u6240\u9700\u7684\u6570\u636E\u8F93\u5165\u8DEF\u5F84");
		 lblNewLabel_26.setFont(new Font("宋体", Font.PLAIN, 18));
		 lblNewLabel_26.setBounds(20, 20, 208, 25);
		 add(lblNewLabel_26);
		
		 JLabel lblNewLabel_25 = new JLabel("\u6570\u636E\u8F93\u5165\u8DEF\u5F84");
		 lblNewLabel_25.setBackground(SystemColor.inactiveCaptionBorder);
		 lblNewLabel_25.setFont(new Font("宋体", Font.PLAIN, 17));
		 lblNewLabel_25.setBounds(20, 60, 120, 33);
		 add(lblNewLabel_25);
		    
		   
		 txtInputPath.setBounds(160, 60, 362, 33);
		 add(txtInputPath);
		 txtInputPath.setColumns(10);
		    
		    
		   
		 btnInputBrowse.setBounds(532, 66, 93, 23);
		 btnInputBrowse.addActionListener(new OpenHandler());
		 add(btnInputBrowse);
	}
	 class OpenHandler implements  ActionListener{
         public void actionPerformed(ActionEvent e) {
			JFileChooser jc=new JFileChooser();
			int rVal=jc.showOpenDialog(JPanelForInputFile.this);
			if(rVal==JFileChooser.APPROVE_OPTION){
				File dir=jc.getCurrentDirectory();
				File file=jc.getSelectedFile();
				txtInputPath.setText(file.toString());
			}
			if(rVal==JFileChooser.CANCEL_OPTION){
				 txtInputPath.setText("You pressed cancel");
			
			}
		}
	}
}
ui\input\view\JPanelForJTree.java
package ui.input.view;
import java.awt.Color;
import java.awt.Font;
import java.awt.event.MouseAdapter;
import javax.swing.ImageIcon;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.UIManager;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
public class JPanelForJTree extends JPanel {
	  
	  DefaultMutableTreeNode root = new DefaultMutableTreeNode("所有系统");
	  DefaultMutableTreeNode root1 = new DefaultMutableTreeNode("算法系统");
	  final DefaultMutableTreeNode node0 = new DefaultMutableTreeNode("算法名称");
	  final DefaultMutableTreeNode node1 = new DefaultMutableTreeNode("算法终止条件");
	  final DefaultMutableTreeNode node2 = new DefaultMutableTreeNode("种群信息");
	  final DefaultMutableTreeNode node3 = new DefaultMutableTreeNode("基因信息");
	  final DefaultMutableTreeNode node4 = new DefaultMutableTreeNode("所需函数和随机数");
	  DefaultMutableTreeNode root2 = new DefaultMutableTreeNode("输入系统");
	  final DefaultMutableTreeNode node5 = new DefaultMutableTreeNode("上传/下载接口");
	  final DefaultMutableTreeNode node6 = new DefaultMutableTreeNode("输入路径");
	  DefaultMutableTreeNode root3 = new DefaultMutableTreeNode("输出系统");
	  final DefaultMutableTreeNode node7 = new DefaultMutableTreeNode("输出结果");
	  
	  
	  final DefaultMutableTreeNode Node[]={node0,node1,node2,node3,node4,node5,node6,node7};
	  DefaultTreeModel treeModel = new DefaultTreeModel(root);
	  final JTree tree_1 ;
	  public JPanelForJTree() {
	 	setBackground(Color.WHITE);
		//树
	 	  treeModel.insertNodeInto(root1, root, root.getChildCount());
		  treeModel.insertNodeInto(root2, root, root.getChildCount());
		  treeModel.insertNodeInto(root3, root, root.getChildCount());
		  
		  treeModel.insertNodeInto(node0, root1, root1.getChildCount());
		  treeModel.insertNodeInto(node1, root1, root1.getChildCount());
		  treeModel.insertNodeInto(node2, root1, root1.getChildCount());
		  treeModel.insertNodeInto(node3, root1, root1.getChildCount());
		  treeModel.insertNodeInto(node4, root1, root1.getChildCount());
		 
		  
		  treeModel.insertNodeInto(node5, root2, root2.getChildCount());
		  treeModel.insertNodeInto(node6, root2, root2.getChildCount());
	      
		  treeModel.insertNodeInto(node7, root3, root3.getChildCount());
		  
		  
		  
		  UIManager.getLookAndFeelDefaults().put("ClassLoader",getClass().getClassLoader());
		  tree_1 = new JTree(treeModel);
		  tree_1.setRowHeight(20);
		  DefaultTreeCellRenderer cellRenderer = (DefaultTreeCellRenderer) tree_1.getCellRenderer();
		  cellRenderer.setLeafIcon(new ImageIcon("//leaf.jpg"));
		  cellRenderer.setOpenIcon(new ImageIcon("//leaf.jpg"));
		  cellRenderer.setClosedIcon(new ImageIcon("//leaf.jpg"));
		  cellRenderer.setFont(new Font("宋体", Font.PLAIN, 15));// 设置字体.
		  cellRenderer.setBackgroundNonSelectionColor(Color.white);
		  cellRenderer.setBorderSelectionColor(Color.red);
		  cellRenderer.setTextNonSelectionColor(Color.black);
		  cellRenderer.setTextSelectionColor(Color.WHITE);
		  cellRenderer.setBorderSelectionColor(Color.blue);
		
		
		/*
		 * 设置选时或不选时，文字的变化颜色
		 */
		  cellRenderer.setTextNonSelectionColor(Color.black);
		  cellRenderer.setTextSelectionColor(Color.WHITE);
		  cellRenderer.setBorderSelectionColor(Color.blue);
		  tree_1.addMouseListener(new MouseAdapter(){});
		  tree_1.setRowHeight(20);
		  JScrollPane scrollPane = new JScrollPane(tree_1);
		  scrollPane.setBounds(0, 0, 155, 455);
		  scrollPane.setVisible(true);
		  setLayout(null);
		  add(scrollPane);
	}
}
ui\input\view\JPanelForSaveConfig.java
package ui.input.view;
import java.awt.Color;
import java.awt.Font;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
public class JPanelForSaveConfig extends JPanel {
	JButton btnSave = new JButton("\u4FDD\u5B58");
	JTextField txtConfigurationName = new JTextField();
	public JPanelForSaveConfig() {
		
		setBounds(155, 115, 631, 447);
		setBackground(Color.WHITE);
		setLayout(null);
		
		JLabel lblNewLabel_33 = new JLabel("\u8BF7\u4E3A\u66F4\u6539\u7684\u914D\u7F6E\u6587\u4EF6\u91CD\u547D\u540D");
		lblNewLabel_33.setFont(new Font("宋体", Font.PLAIN, 18));
		lblNewLabel_33.setBounds(20, 20, 216, 25);
		add(lblNewLabel_33);
		
		JLabel lblNewLabel_34 = new JLabel("\u914D\u7F6E\u6587\u4EF6\u540D");
		lblNewLabel_34.setFont(new Font("宋体", Font.PLAIN, 15));
		lblNewLabel_34.setBounds(20, 60, 106, 25);
		add(lblNewLabel_34);
		
		
		txtConfigurationName.setBounds(132, 62, 271, 25);
		add(txtConfigurationName);
		txtConfigurationName.setColumns(10);
		
		
		
		btnSave.setBounds(423, 62, 78, 23);
		add(btnSave);
	}
}
ui\input\view\JPanelForUploadInterface.java
package ui.input.view;
import java.awt.Color;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JLabel;
import java.awt.Font;
import javax.swing.JTextField;
import javax.swing.JButton;
import ui.input.controller.ModelForDownLoadInterface;
import ui.input.controller.UploadInterfaceController;
import ui.input.model.ModelForUploadInterface;
import ui.input.view.JPanelForInputFile.OpenHandler;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.io.File;
import java.io.IOException;
import javax.swing.border.LineBorder;
public class JPanelForUploadInterface extends JPanel {
    public JTextField textInterfaceName = new JTextField();
	public JLabel lblNewLabel = new JLabel("\u63A5\u53E3\u540D");
	public JButton button = new JButton("\u6D4F\u89C8");
	public JButton btnUpload = new JButton("\u4E0A\u4F20");
	public JTextField textInterfacePath = new JTextField();
	public JLabel lblNewLabel_2 = new JLabel("\u63A5\u53E3\u8DEF\u5F84");
	public File dir,file;
	//
	public JLabel lblNewLabel2 = new JLabel("\u53EF\u4F9B\u4E0B\u8F7D\u7684\u63A5\u53E3");
	public JButton buttonSaveDirBrowse = new JButton("\u6D4F\u89C8");
	public JButton btnDownLoad = new JButton("\u4E0B\u8F7D");
	public JTextField textInterfaceSavePath = new JTextField();
	public JLabel lblNewLabel3 = new JLabel("\u4FDD\u5B58\u8DEF\u5F84");
	public File dirForSavePath,fileForSeleInterface;
	JComboBox interfaceComboBox = new JComboBox();
	/**
	 * Create the panel.
	 */
	public JPanelForUploadInterface() {
		setBorder(new LineBorder(new Color(0, 0, 0)));
		setBounds(155, 115, 673, 479);
		setBackground(Color.WHITE);
		setLayout(null);
		
		
		lblNewLabel.setFont(new Font("宋体", Font.PLAIN, 18));
		lblNewLabel.setBounds(30, 80, 76, 23);
		add(lblNewLabel);
		
		
		textInterfaceName.setBounds(192, 80, 262, 25);
		add(textInterfaceName);
		textInterfaceName.setColumns(10);
		
		
		button.addActionListener(
				new OpenHandler()
		);
		button.setBounds(505, 80, 93, 23);
		add(button);
		btnUpload.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				ModelForUploadInterface uploadInterface=new ModelForUploadInterface(file,dir,textInterfaceName.getText(),textInterfacePath.getText());
				try {
					int result=UploadInterfaceController.btnUploadController(uploadInterface);
					if(result==-1){
						JOptionPane.showMessageDialog(null, "该文件已存在，请重新选择上传文件");
						textInterfaceName.setText("");
						textInterfacePath.setText("");
					}
					else if(result==0){
						JOptionPane.showMessageDialog(null, "上传成功");
					}
					else if(result==-2){
						JOptionPane.showMessageDialog(null, "该文件没有实现指定接口，上传失败");
						textInterfaceName.setText("");
						textInterfacePath.setText("");
					}
					else{
						JOptionPane.showMessageDialog(null, "该文件没有缺省的构造函数，上传失败");
						textInterfaceName.setText("");
						textInterfacePath.setText("");
					}
					
				} catch (IOException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
			}
		});
		
		
		btnUpload.setBounds(505, 140, 93, 23);
		add(btnUpload);
		
		
		lblNewLabel_2.setFont(new Font("宋体", Font.PLAIN, 18));
		lblNewLabel_2.setBounds(30, 140, 76, 25);
		add(lblNewLabel_2);
		
		
		textInterfacePath.setBounds(192, 140, 262, 25);
		add(textInterfacePath);
		textInterfacePath.setColumns(10);
		setVisible(true);
		
		
		
		
		
		
		
		
		//------------------------------------------------------
		lblNewLabel2.setFont(new Font("宋体", Font.PLAIN, 18));
		lblNewLabel2.setBounds(30, 260, 141, 23);
		add(lblNewLabel2);
		
		
		buttonSaveDirBrowse.addActionListener(
				new OpenHandler()
		);
		buttonSaveDirBrowse.setBounds(505, 320, 93, 23);
		add(buttonSaveDirBrowse);
		btnDownLoad.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				ModelForDownLoadInterface downLoadInterface=new ModelForDownLoadInterface(file,dir,textInterfaceSavePath.getText(),textInterfaceSavePath.getText());
				
			}
		});
		
		
		btnDownLoad.setBounds(505, 390, 93, 23);
		add(btnDownLoad);
		
		
		lblNewLabel3.setFont(new Font("宋体", Font.PLAIN, 18));
		lblNewLabel3.setBounds(30, 320, 76, 25);
		add(lblNewLabel3);
		
		
		textInterfaceSavePath.setBounds(192, 320, 262, 25);
		add(textInterfaceSavePath);
		textInterfaceSavePath.setColumns(10);
		
		
		interfaceComboBox.setBounds(192, 260, 262, 25);
		add(interfaceComboBox);
		
		JLabel label = new JLabel("\u4E0A\u4F20\u63A5\u53E3");
		label.setForeground(new Color(0, 0, 0));
		label.setFont(new Font("宋体", Font.PLAIN, 18));
		label.setBounds(30, 25, 84, 23);
		add(label);
		
		JLabel lblNewLabel_1 = new JLabel("\u4E0B\u8F7D\u63A5\u53E3");
		lblNewLabel_1.setFont(new Font("宋体", Font.PLAIN, 18));
		lblNewLabel_1.setBounds(30, 203, 72, 30);
		add(lblNewLabel_1);
		setVisible(true);
	}
	class OpenHandler implements  ActionListener{
        public void actionPerformed(ActionEvent e) {
			JFileChooser jc=new JFileChooser();
			int rVal=jc.showOpenDialog(JPanelForUploadInterface.this);
			if(rVal==JFileChooser.APPROVE_OPTION){
			    dir=jc.getCurrentDirectory();
				file=jc.getSelectedFile();
				textInterfaceName.setText(file.getName());
				textInterfacePath.setText(dir.toString());
			}
			if(rVal==JFileChooser.CANCEL_OPTION){
				 textInterfaceName.setText("You pressed cancel");
			
			}
		}
	}
}
ui\input\view\New2.java
package ui.input.view;
import java.awt.CardLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import org.jvnet.substance.SubstanceLookAndFeel;
import ui.alg.Model.ModelForJPanelConfig;
import ui.alg.Model.ModelForJPanelFunction;
import ui.alg.Model.ModelForJPanelGEne;
import ui.alg.Model.ModelForJPanelPopulation;
import ui.alg.controller.FunctionPanelController;
import ui.alg.controller.HostPanelController;
import ui.alg.view.HostPanel;
import ui.alg.view.JPanelForFunction;
import ui.alg.view.JPanelForGene;
import ui.alg.view.JPanelForStopSetting;
import ui.alg.view.JPanelForPopulation;
import ui.input.controller.*;
import ui.input.model.ModelForJPanelInputPath;
import ui.input.model.ModelForUploadInterface;
import ui.output.controller.OutputPanelController;
import ui.output.view.JPanelForOutput;
import domain.core.outputmodel.GepConfiguration;
import domain.iservice.IgepAlgService;
import domain.service.alg.configuration.GepAlgService;
import domain.service.input.DefaultGepInput;
import domain.service.input.IgepInput;
import exception.Duplicated;
public class New2 extends JFrame {
    JPanel contentPane;
    HostPanel configurationPanel;
	JPanelForStopSetting stopSettingPanel=new JPanelForStopSetting();
	JPanelForPopulation populationPanel=new JPanelForPopulation();
	JPanelForGene genePanel=new JPanelForGene();
	JPanelForFunction functionPanel=new JPanelForFunction();
	JPanelForFooter footPanel=new JPanelForFooter();
	JPanelForUploadInterface uploadInterfacePanel=new JPanelForUploadInterface();
	JPanelForInputFile inputFilePanel=new JPanelForInputFile();
	JPanelForJTree  treePanel;
	JPanelForSaveConfig scfigNamePanel=new JPanelForSaveConfig();
	JPanelForOutput outputPanel=new JPanelForOutput();
    JPanel panel_0 = new JPanel();
   
	CardLayout card;
	
   
	GepConfiguration myParameter=new GepConfiguration();
	IgepAlgService myGepService=new GepAlgService();	
	GepConfiguration myConfigurationFromDB;
	List<GepConfiguration> configurationsOfHistory=myGepService.readArgumentsFromDb();
	IgepInput input =new DefaultGepInput();
	int flag=0;//是否读取配置文件
	int count=0;
	int jcount=1;//标记jcomboBoxConfiguration的editor事件还是ItemSelectedchange事件
	public static void main(String[] args) {
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					New2 frame = new New2();
					frame.setVisible(true);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}
	
	public New2() throws ClassNotFoundException, InstantiationException, IllegalAccessException, UnsupportedLookAndFeelException {
		//javax.swing.UIManager.setLookAndFeel("com.jtattoo.plaf.smart.SmartLookAndFeel");
		//javax.swing.UIManager.setLookAndFeel("com.jtattoo.plaf.mcwin.McWinLookAndFeel");
		//javax.swing.UIManager.setLookAndFeel("com.jtattoo.plaf.luna.LunaLookAndFeel");
		//javax.swing.UIManager.setLookAndFeel("com.jtattoo.plaf.aluminium.AluminiumLookAndFeel");
		//javax.swing.UIManager.setLookAndFeel("com.jtattoo.plaf.bernstein.BernsteinLookAndFeel");
		//javax.swing.UIManager.setLookAndFeel("com.jtattoo.plaf.hifi.HiFiLookAndFeel");
		javax.swing.UIManager.setLookAndFeel("com.jtattoo.plaf.mint.MintLookAndFeel");
		//javax.swing.UIManager.setLookAndFeel("com.jtattoo.plaf.aero.AeroLookAndFeel");
		//javax.swing.UIManager.setLookAndFeel("com.jtattoo.plaf.fast.FastLookAndFeel");
		//javax.swing.UIManager.setLookAndFeel("com.jtattoo.plaf.acryl.AcrylLookAndFeel");
		//javax.swing.UIManager.setLookAndFeel("com.jtattoo.plaf.noire.NoireLookAndFeel"); 
		
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setBounds(100, 100, 850, 686);
		contentPane = new JPanel();
		contentPane.setBackground(Color.WHITE);
		contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));
		setContentPane(contentPane);
		contentPane.setLayout(null);
		
		
		
		panel_0.setBorder(new LineBorder(new Color(0, 0, 0)));
		panel_0.setBackground(Color.WHITE);
		panel_0.setBounds(165, 115, 659, 399);
	    card = new CardLayout(5, 5);
		panel_0.setLayout(card);
		contentPane.add(panel_0);
		
		
		
		
		   
		
	
		  
		  //算法名称面板-------------------------------------------------
		  
		 
		   String configurations[] = new String[configurationsOfHistory.size()];
		   for (int i = 0; i < configurationsOfHistory.size(); i++) {
				String configName = configurationsOfHistory.get(i).getName();
				configurations[i] = configName;
			}
			final JComboBox jcomboBoxConfiguration = new JComboBox(configurations);
			
			Component scrollBtn=jcomboBoxConfiguration.getComponent(0);
			configurationPanel=new HostPanel(jcomboBoxConfiguration);
			configurationPanel.setBorder(null);
			configurationPanel.setBounds(155, 115, 631, 447);
			configurationPanel.setVisible(true);
		    scrollBtn.addMouseListener(new MouseAdapter() {
		       public void mouseClicked(MouseEvent arg0) {
		    	   jcount=1;
		       }
           });
		  configurationPanel.btnSetConfig.addActionListener(new ActionListener(){
				public void actionPerformed(ActionEvent e) {
					HostPanelController.btnSetConfigController(stopSettingPanel, populationPanel, genePanel, functionPanel, inputFilePanel);
					card.next(panel_0);
					TreePath visiblePath=new TreePath(((DefaultTreeModel)treePanel.tree_1.getModel()).getPathToRoot(treePanel.node1));
		    		treePanel.tree_1.setSelectionPath(visiblePath);
					jcount=2;
					footPanel.btnRun.setEnabled(false);
				}
				
			});
		  jcomboBoxConfiguration.getEditor().getEditorComponent().addKeyListener(new KeyAdapter(){    
			    public void keyPressed(KeyEvent e) {
			    	HostPanelController.jcomboBoxEditorController(e,configurationPanel.btnSetConfig);
			        footPanel.btnRun.setEnabled(false);
			        HostPanelController.btnSetConfigController(stopSettingPanel, populationPanel, genePanel, functionPanel, inputFilePanel);
			        jcount=2;
			    }  
			    
			});
		  
		  jcomboBoxConfiguration.addItemListener(new  ItemListener(){ 
              public void  itemStateChanged(ItemEvent   ie){ 
            	if(jcount!=2){
            	 myConfigurationFromDB = configurationsOfHistory.get(jcomboBoxConfiguration.getSelectedIndex());
            	 System.out.println(myConfigurationFromDB.toString());
            	 flag=-1;
            	 setTitle(myConfigurationFromDB.toString());
                 footPanel.btnRun.setEnabled(true);
            	 HostPanelController.jcomboBoxItemController(ie,configurationPanel, stopSettingPanel, populationPanel, genePanel, functionPanel, footPanel,inputFilePanel ,myConfigurationFromDB, configurationsOfHistory, myGepService);
            	 jcount=1;
            	}
               }
             }
		  );
		
		  panel_0.add(configurationPanel,"p1");
		  
		  //选择输入路径面板-------------------------------------------------
		  stopSettingPanel.setBorder(null);
		  stopSettingPanel.setVisible(false);
		  panel_0.add(stopSettingPanel,"p2");
		  
		  //种群面板------------------------------------------------
		  
		  populationPanel.setBorder(null);
		  populationPanel.setVisible(false);
		  try {
				for (int i = 0; i < myGepService.getAvailableSelector().size(); i++) {
					populationPanel.JComboBoxofSelectionStrategy.addItem(myGepService.getAvailableSelector().get(i).toString());
				}
				for (int i = 0; i < myGepService.getAvailableCalculator().size(); i++) {
	                 populationPanel.JComboBoxAvailableCalculator.addItem(myGepService.getAvailableCalculator().get(i).toString());
				}
				for (int i = 0; i < myGepService.getAvailableCreator().size(); i++) {
					populationPanel.JcomboBoxOfPopulationCreator.addItem(myGepService.getAvailableCreator().get(i).toString());
				}
			} catch (ClassNotFoundException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			} catch (InstantiationException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			} catch (IllegalAccessException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			
		  panel_0.add(populationPanel,"p3");
		  //基因面板---------------------------------------------
		  genePanel.setBorder(null);
		  genePanel.setVisible(false);
		  try {
				for (int i = 0; i < myGepService.getAvailableModifyings().size(); i++) {
					genePanel.JComboBoxOfAvailableModifyings.addItem(myGepService.getAvailableModifyings().get(i).toString());
				}
			} catch (ClassNotFoundException e1) {
				e1.printStackTrace();
			} catch (InstantiationException e1) {
				e1.printStackTrace();
			} catch (IllegalAccessException e1) {
				e1.printStackTrace();
			}
		  panel_0.add(genePanel,"p4");
		  //函数面板----------------------------------
		 
		  functionPanel.setBorder(null);
		  functionPanel.setVisible(false);
		  try {
				for (int i = 0; i < myGepService.getAvailableFunctions().size(); i++) {
					functionPanel.comboBox.addItem(myGepServ